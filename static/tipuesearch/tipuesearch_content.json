{"pages":[{"title":"NestedReact","text":"NestedReact bridges the gap between React and traditional MVC frameworks, combining familiar OO state management and two-way data binding with all the benefits of true unidirectional data flow. It's MVC framework taking React for \"V\" and NestedTypes for \"M\", while being unopinionated on \"C\". NestedTypes for &quot;M&quot; Does to your data the same as React does to the DOM. Observable (reactive) data structures Easy state synchronization Automatic serialization and REST Aggregation, &quot;to-one&quot;, and &quot;to-many&quot; relashionships. Type annotations and assertions 10 times faster than BackboneJS. React for &quot;V&quot; React. Extended to play well with MVC. Simple technique to manage all application state Handle complex UI state with NestedTypes Unidirectional data flow Automatic &quot;pure render&quot; optimization Handle forms naturally Two-way data binding Declarative form validation React mixins with ES6 classes. Cuts your code 2-5x compared to React\/Redux. Choose your &quot;C&quot; react-router No router Whatever-you-like router","tags":"","url":"index.html"},{"title":"Getting Started","text":"NestedReact is the front-end framework which brings advantages of React's view layer to the classic MVC architecture which is familiar to the most application developers. You've got the complete solution covering all needs of large SPA except the routing (choose the one which suites you best). Models as data layer building blocks: looks like plain JS classes; recursively composable (can consists of other models and collections); deeply observable (&quot;reactive&quot;); automatically serializable (any model can be instantly turned to the REST endpoint); aware of one-to-many and many-to-many relations out of the box. Unified state management. No more component.setState(): component's state is the model (looks like plain object, observable, serializable, etc); components observes state changes and update itself. Forms handling as you expect it to be in XXIst century: completely declarative; two-way data binding; form inputs validation. Unidirectional data flow and pure render. No tricks. No mind-blowing concepts or crazy looking code. It just works. React Mixins support for ES6 classes components. Easy migration from BackboneJS, if you need it. NestedReact is built around NestedTypes data framework (for M), React (for V), and don't enforce any routing solution (unopinionated on C). NestedTypes is the data framework which basically does the same thing to data that React does to DOM: it helps you to describe object trees in declarative way; it updates existing (mutable) object trees in place applying the difference of existing objects to the JSON received from the server. it triggers change events only when there are real changes. Basic Usage NestedReact exports modified React namespace (original React is untouched). So, use it as React replacement like this: import React from 'nestedreact' The most important thing NestedReact does is universal state management; the same technique is used for handling both component's local UI state, persistent data, and shared global state. In the simplest case of the local UI state, it looks to your as if your state just instantly became observable. You handle the flat state as if it would be the plain object. export const MyComponent = React.createClass({ state : { count : 0 }, render(){ const { state } = this; return ( &lt;div onClick={ () =&gt; state.count++ }&gt; { state.count } &lt;\/div&gt; ); } }); In case of ES6 classes components specification members becomes statics and definition must be preceded with the @define decorator. import React, { define } from 'nestedreact' @define export class MyComponent extends React.Component { static state = { count : 0 } render(){ const { state } = this; return ( &lt;div onClick={ () =&gt; state.count++ }&gt; { state.count } &lt;\/div&gt; ); } } If you prefer to avoid decorators, just invoke component's static define() method directly after the class definition. MyComponent.define(); If you prefer to avoid inline statics, you may pass the specification directly to the define() method: MyComponent.define({ state : { count : 0 } }); Installation All modern browsers and IE10+ are supported. Packed as UMD, can be installed using npm. Requires nestedtypes, react, and react-dom as a peer dependencies. NestedTypes itself can be used as a drop-in BackboneJS replacement, and thus requires jquery and underscore as peer dependencies. Therefore: npm install react react-dom nestedreact nestedtypes jquery underscore --save-dev See examples in the examples folder for the starting boilerplate. Optimizing for size If you're not interested in legacy technologies support and would like to reduce the size of your app assembly, wait a bit for stripped version which is one the way. Meanwhile, you can: Omit jQuery. Without that Model\/Collection REST endpoints and Backbone shims will stop working. Use lightweight jQuery replacements in the same way as people do with Backbone. Don't bother and enjoy. That extra legacy stuff is really the small fraction of the assembly. Why another JS framework React was the huge advancement over client side templating solutions used previously for &quot;V&quot; in the majority of MVC frameworks. Unfortunately, we don't feel the same about the application state management architectures being advocated by Facebook. As NestedReact demonstrates, the dramatical shift in paradigm is not required. It is possible to implement unidirectional data flow with &quot;dirty&quot; mutable data. And it's not only possible, but highly beneficial. Here's TodoMVC solution size chart for different frameworks and combinations of tools. As you can see, an old-school MVC approach the majority of developers are perfectly familiar with allowing us to write twice less code for the same task than all the &quot;flux&quot; stuff. So the overall result is comparable to Angular 2. We're in the same league now. If you take flux-comparison example, difference will become even more spectacular. Here's our solution. Check it out.","tags":"","url":"Getting_Started.html"},{"title":"State Management 101","text":"The first and most notable thing NestedReact does is that it deprecates React state, replacing it with NestedTypes model. Thus, you have the single technique to manage all the state in your application. You start with importing React from nestedreact. import React, { define } from 'nestedreact' Definition of the component must be preceded with @define decorator. @define export class MyComponent extends React.Component { Then, we define the state. In the simplest case, the definition looks like the plain JS object where state attributes are listed along with their default values. All attributes of the state you're going to use must be declared. static state = { count : 0 } And then, you just access this.state as if it would be the plain object. render(){ const { state } = this; return ( &lt;div onClick={ () =&gt; state.count++ }&gt; { state.count } &lt;\/div&gt; ); } } Fairly simple. Now, it's time to describe what really happens behind the scene inside of the @define decorator and how this example works. NestedTypes models as React state First, @define looks for the state static variable. If it present, it defines the NestedTypes model describing the state. Whatever you write in state will just go to this model's attributes spec. Like this: @define class MyState extends Nested.Model { static attributes = { count : 0 } } Then, it will attach special mixin to your component which will create an instance of this model before mount, and will subscribe to the model changes to update UI. It works as if you have the following code in your component: componentWillMount(){ this.state = new MyState(); } componentDidMount(){ this.state.on( 'change', () =&gt; this.forceUpdate() ); } An then, considering the fact that NestedTypes model behaves mostly as an object with observable changes, you can just assign this.state.count directly. Which will emit change event, and trigger UI update. Alternatively, you can define the state separately like we did here and tell the component to use it as state. You just need to use Model static property instead of state. static Model = MyState;","tags":"","url":"Basics\/State_Management_101.html"},{"title":"Two way data binding","text":"All modern JS frontend application frameworks supports two-way data binding. NestedReact is not an exception. In this example we will bind the state member to the input control. In order to use data binding, you need to import data bound controls from nestedreact\/tags.jsx module first. import React, { define } from 'nestedreact' import { Input } from 'nestedreact\/tags.jsx' Then, you have to create data binding link for the state attribute using getLink( key ) method, and pass it to valueLink Input's property. @define export class MyComponent extends React.Component { static state = { text : '' } render(){ return &lt;Input valueLink={ this.state.getLink( 'text' )} \/&gt;; } } Link can be created for any NestedTypes model attribute (and state is the NestedTypes model internally). const link = model.getLink( 'attr' ) If you have a form with a lot of controls, you can create links in a bulk with a single line using model.linkAll( ... ) method. Which is the preferable way of dealing with the complex forms. render(){ const links = this.state.linkAll( 'a', 'b', 'c' ); return ( &lt;form&gt; &lt;Input valueLink={ links.a } \/&gt; &lt;Input valueLink={ links.b } \/&gt; &lt;Input valueLink={ links.c } \/&gt; &lt;\/form&gt; ); } How it works To explain valuelink pattern simply, is an object holding the value and the callback to update the value. It is something close to this: render(){ const link = { value : this.state.text, set : x =&gt; this.state.text = x }; return &lt;Input valueLink={ link } \/&gt;; } And, an Input control which consumes such a link would look like this: const Input = ({ valueLink }) =&gt; ( &lt;input value={ valueLink.value } onChange={ e =&gt; valueLink.set( e.target.value ) \/&gt; ); NestedReact's link implementation works close to the code above, but is way more sophisticated. Links are cached inside of the React component, so they are reused on subsequent render if the enclosed value is was not changed. Links also the basis for declarative form validation. NestedReact's links are also available as a separate package, and can be used independently.","tags":"","url":"Basics\/Two_way_data_binding.html"},{"title":"Dirty Top And Pure Bottom ","text":"&quot;Complex state&quot; is the state composed of nested parts (typically other models and collections). It's done with mentioning type constructors in model or state attribute declaration instead of the default value. Such a members called aggregated members. When the model is... ...created with new, aggregated members are created too. ...cloned with model.clone(), aggregated members are cloned. ...disposed with model.dispose(), aggregated members are disposed. And when nested models and collections are modified, root model holding React component state detects the change, and force its component to update. In conjunction, these features allows to to describe fairly complex components using just component state. Example: unidirectional data flow with complex state Here we're demonstrating the main pattern which is used to structure applications with NestedReact. Top-level &quot;dirty&quot; component holding the complex mutable state, passing its parts down to &quot;pure&quot; children components with props. In order to define models which are parts of the React state, you will need to import Model base class from nestedtypes. import { Model, define } from 'nestedtypes' import React from 'nestedreact' It doesn't matter where @define decorator comes from, it's the same. Now lets define some simple model. @define class Counter extends Nested.Model { static attributes = { count : 0 } } Then, use it to define more complex structure. Model collection can be referenced as Model.Collection, and mostly conforms to BackboneJS collection API. They can be created directly with new or used as attribute type. @define class ComplexState extends Nested.Model { static attributes = { created : Date, counter : Counter, counters : Counter.Collection } } And now, let's define some root component managing the complex UI state. @define class View extends React.Component { static state = { \/\/ &lt;- define the model describing UI state dummy : ComplexState } render(){ return ( &lt;div&gt; { this.state.dummy.counters.map( counter =&gt; ( &lt;CounterItem key={ counter.cid } model={ counter } \/&gt; ) ) } &lt;\/div&gt; ); } } And finally, we can make pure component for the counter, receiving the nested model in props. It will handle the click, and increment the counter. Which will be noticed by the root component because this counter is the part of its complex state, thus it will trigger UI update. const CounterItem = ({ model }) =&gt; ( &lt;div onClick={ () =&gt; model.counter++ }&gt; { model.counter } &lt;\/div&gt; ); Conceptually, this is the most common pattern of structuring an application in the majority of the functional languages which are used for production in the wild. Those like OCaml (and F#), or Erlang (and Elixir).","tags":"","url":"Handling_The_Complex_State\/Dirty_Top_And_Pure_Bottom .html"},{"title":"State and Props Type Annotations","text":"In NestedTypes, model does not behave like key-value hash but rather like a record or class from statically typed languages like Java or C++. All model attributes have to be declared and they are typed. Full form of attribute type annotation is this: attrName : Constructor.value( defaultValue ) With this spec, attribute will be initialized like this: model.attrName = new Constructor( defaultValue ) Two shorter forms of the type spec are: attrName : defaultValue. Attribute type will be inferred from the default value. attrName : Constructor. Every function here is assumed to be constructor. For an attribute of type Function you have to use full form of the spec: attrName : Function.value( x =&gt; x ) Type inference can be turned off completely with Nested.value( ... ) spec: attrName : Nested.value( x =&gt; x ) Dynamic Type Safety NestedTypes uses information about types in the variety of different ways. Although it doesn't check types at compile time, it guarantees that attributes will always have values of declared types because they are guarded with run-time type assertions and automatic type casts. Type casts are performed slightly differently for different types, but semantically they follow the simple rule: value of incompatible type is being passed as an argument to the attribute's type constructor. m.attr = new Constructor( incompatibleValue ); @define class Sample extends Nested.Model { static attributes = { time : Date, num : 0, \/\/ same as Number or Number.value( 0 ) str : '', \/\/ same as String or String.value( '' ) bool : false \/\/ same as Boolean or Boolean.value( false ) any : null \/\/ same as Nested.value( null ). Untyped attribute. } } const s = new Sample(); s.time = 32787878; \/\/ = new Date( 32787878 ) s.num = &quot;676743&quot;; \/\/ = 676743 s.num = &quot;hjkghjgfdsj&quot;; \/\/ = NaN s.str = 123; \/\/ = &quot;123&quot; s.bool = s.num &amp;&amp; s.str; \/\/ = Boolean( s.num &amp;&amp; s.str ) s.any = holdsAnothing; \/\/ no type convertions. Even if you omit explicit type annotation, attribute is still typed (and guarded) according to the type of the default value. To turn type inference off in attribute declaration, either specify null or void 0 as default value, or use Nested.value( defaultValue ) as type spec. Props and Context Type Annotations Same style type annotations may be used for the props as a replacement for propTypes and getDefaultProps(). As they are just compiled to propTypes and getDefaultProps(), they works a bit differently from the state attributes annotations: No automatic type conversion. Just standard propTypes type asserts. Default value is created only when it is provided explicitly. It works in the same way for the context and childContext as a replacement for React's contextTypes and childContextTypes respectively. But default values are ignored. @define class MyComponent extends React.Component { static props = { callback : Function.value( () =&gt; void 0 ), optionalProp : String, \/\/ no default value propWithDefaultValue : '' } render(){ ... } }","tags":"","url":"Handling_The_Complex_State\/State_and_Props_Type_Annotations.html"},{"title":"Update Watchers and Transactions","text":"NestedTypes (and NestedReact) gives you precise control over the way how state is being changed, allowing you to watch attributes for changes and attach some reactions to it. This (and variety of other things) can be done with the help of has type annotation. In this example, we have local state member, which is a string. On every change it will call the watcher function, which is taken from the props. @define const MyComponent extends React.Component { static props = { callback : Function.value( x =&gt; void 0 ) } static state = { local : String.has.watcher( '^props.callback' ) } render(){ ... } } .has.watcher( path | function ) annotation either takes &quot;watcher&quot; function as an argument, or the string path to the watcher function taken relative to the current model's this. ^ in the path is the shorthand for the getOwner() call, which in our case returns React component itself. So, ^props.callback is being translated to this: this.getOwner().props.callback. How watchers works NestedTypes is mostly backward compatible with BackboneJS in term of events emitted by models and collections. The difference is that mechanics of change events and updates is generalized on the case of nested models and collection. How model tree handles an update All updates are executed in the scope of transactions, and transaction have three stages. At the first stage, update is applied and attributes receive the new values. At the second stage, change:attrName event is being triggered for every changed attribute. Any additional changes to the current models and its attributes which made as a reaction to these events are executed in the scope of the same transaction and will trigger additional change:attr events. At the third stage, model triggers change event, and when change event processing sequence is done, it closes the transaction and notifies upper level model, collection, or React component (if any) of change. Therefore, change events handlers are synchronous, but they are executed as wave from bottom to the top. And updates made from inside of the handlers won't result in additional change events at the upper levels. Attribute watcher behaves mostly similar to change:attrName event handler, with the following differences: Relative symbolic references (paths) to event handlers are allowed, and handler is called with the right context according to the path. Event handler receives the new attribute value as first argument. Event handler can be missing, it's fine. For the case of the collection, the transactions mechanic is the same, with a difference that individual model's add, remove, and change events are emitted during the phase 2 instead of change:attrName, and changes event is triggered at the stage 3 instead of change. Explicit transactions control Every model attribute assignment or collection modification create implicit transaction which triggers the wave of change events from the bottom to the top. You can group the series of modifications to the single transaction explicitly with transaction() method. my.model.transaction( model =&gt; { model.a = 1; model.and.nested.attr = 2; model.itemsCollection.add( { id: 1, name : 'Hi' } ); }); This code executed synchronously and results in the single change event triggered by my.model only in case there have been any real changes made, i.e. model.a wasn't already equal to 1 and so on. This technique works for both models and collections, can improve performance, and reduce overall amount of renders. Additionally, collection has transactional version of each() method (collection.updateEach()) which iterates through the collection in the scope of transaction. There are other methods of model and collection which are transactional: model.set( { a : 1, b : 2, ... } ) collection.set( ... ), collection.add( ... ), collection.remove( ... )","tags":"","url":"Handling_The_Complex_State\/Update_Watchers_and_Transactions.html"},{"title":"Advanced State Management","text":"Handling the complex state Nested Models and Collections State is NestedTypes model. Models 101. Passing down nested models and collections as props Nested JSON For link enclosings arrays and plain JS objects: arrOrObjLink.at( key ) creates link to array of object member with a given key. Can be applied multiple times to work with object hierarchies; on modifications, objects will be updated in purely functional way (modified parts will be shallow copied). Useful when working with plain JS objects in model attributes - updating them through links make changes visible to the model. arrOrObjLink.map( ( itemLink, key ) =&gt; &lt;input key={ key } valieLink={ itemLink } \/&gt; ) iterates through object or array, wrapping its elements to links. Useful for JSX transofrmation. Links is NestedLink library Passing down links to objects Old Passing models and collections as components props It's quite common practice to describe complex application's page state in top-level component, and pass the parts of the state down as props. In this case, any changes to nested models and collections will be detected by top-level component and will cause update of the whole subtree. Resulting in so-called unidirectional data flow. \/\/ data layer const Counter = Model.extend({ attributes : { count : 0 } }); \/\/ Application or application's page const Top = React.createClass({ \/\/ all changes made to the parts of the state will cause component update state : { model1 : Counter, model2 : Counter }, render(){ \/\/ pass down elements of the state... return ( &lt;div&gt; &lt;Bottom model={ this.state.model1 } \/&gt; &lt;Bottom model={ this.state.model2 } \/&gt; &lt;\/div&gt; ); } }); \/\/ Pure component. Click will trigger update of the Top component. const Bottom = ({ model }) =&gt; ( &lt;div onClick={ () =&gt; model.count += 1 }&gt; { model.count } &lt;\/div&gt; ); Also, this example demonstrates the point which really differentiate our approach to application state management. Here the simple fact comes into play - NestedTypes models can declaratively describe very complex state, and detect deeply nested changes. So, you have unidirectional data flow for no effort. Links and components state Link received through component props can be mapped as state member using the following declaration: state : { selected : Nested.link( '^props.selectedLink' ) } It can be accessed as a part of state, however, in this case it's not true state. All read\/write operations will be done with link itself, and local state won't be modified. Also, links can be used to declaratively expose real component state to upper conponents. In this example, link optionally received in props will be updated every time this.state.selected object is replaced. In this case, updates are one way, from bottom component to upper one, and stateful component will render itself when state is changed. state : { selected : Item.has.watcher( '^props.selectedLink.set' ) } Technically, &quot;watcher&quot; - is just a callback function with a single argument receiving new attribute value, so links are not required here.","tags":"","url":"Handling_The_Complex_State\/Advanced State Management.html"},{"title":"Form Validation","text":"How it works Links carry additional validationError field for validation purposes (to be used inside of custom UI controls). It's populated automatically for links created from models and collection, utilizing nestedtypes validation mechanics. Therefore, if model attribute has any check attached, its link will carry its validationError object. var M = Nested.Model.extend({ defaults : { attr : Number.has.check( x =&gt; x &gt; 0, 'attr should be positive' ) } }); ... var m = new M({ attr : -1 }); var attrLink = m.getLink( 'attr' ); console.assert( m.value === -1 ); console.assert( m.validationError === 'attr should be positive' ); It's possible to use ad-hoc validation in component's render method with link.check method. var link = model.getLink( 'something' ) .check( x =&gt; x &gt; 0, 'Shoulld be positive' ) .check( x =&gt; x &lt; 10, 'Shoulld be lesser than 10' ); Failed checks will populate link's validationError with first failed check's message.","tags":"","url":"Working_With_Forms\/Form_Validation.html"},{"title":"Advanced Data Binding","text":"Data binding examples Here are the set of examples for typical nestedreact data binding use cases. Each section contains custom databound component, model definitions, and usage examples. Somewhere at the top level component(s) there must be the declaration linking model updates to UI. Either models must be (nested) members of some component's state (which will update UI even in case of deep changes), or you may link component updates to changes of models and collections passed in props. In the last case, you will need to add following line to top or middle-level component definition: listenToProps : 'myModel myCollection' It's generally advised to keep stateful components at the top level, and use listenToProps in the middle level for optimization purposes if you want local updates. Keep you bottom-level components pure, and try to do the same for the most of your middle level (listenToProps used wisely won't hurt). For further information on this topic consult the top-level guide. Link transformations Attribute's link can be further transformed using extended link API. Link transformations allowing you to use new stateless functions component definition style introduced in React 0.14 in most cases. For links with any value type: link.equals( x ) creates boolean link which is true whenever link value is equal to x. Useful for radio groups. link.update( x =&gt; !x ) creates function transforming link value (toggling boolean value in this case). Useful for onClick event handlers. For link enclosing array: arrLink.contains( x ) creates boolean link which is true whenever x is contained in an array in link value. Useful for checkboxes. Avoid long arrays, currently operations has O(N^2) complexity. Checkboxes Standard &lt;input\/&gt; will work. Custom Checkbox component might be implemented like this: const Checkbox = ({ className = 'checkbox', checkedLink }) =&gt; ( &lt;div className={ className + ( checkedLink.value ? ' selected' : '' ) } onClick = { checkedLink.update( x =&gt; !x ) } \/&gt; ); Examples will assume working with custom Checkbox. Binding to boolean model attributes import { Model } from 'nestedtypes' const MyModel = Model .defaults({ option1 : true, option2 : false }); const CheckboxGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; ( &lt;div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ model.getLink( 'option1' ) } \/&gt; Option 1 &lt;\/div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ model.getLink( 'option2' ) } \/&gt; Option 2 &lt;\/div&gt; &lt;\/div&gt; ); Binding to array of selected options import { Model } from 'nestedtypes' const MyModel = Model .defaults({ options : [ 'option1' ] }); const CheckboxGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; { const link = model.getLink( 'options' ); return ( &lt;div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ link.contains( 'option1' ) } \/&gt; Option 1 &lt;\/div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ link.contains( 'option2' ) } \/&gt; Option 2 &lt;\/div&gt; &lt;\/div&gt; ); }; Binding to collection of selected models import { Model } from 'nestedtypes' const MyModel = Model .defaults({ all : Some.Collection, selected : Collection.subsetOf( 'all' ) }); const CheckboxGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; { const { all, selected } = model; return ( &lt;div&gt; { all.map( model =&gt; ( &lt;div&gt; &lt;Checkbox checkedLink={ selected.getLink( model ) } \/&gt; { model.displayName } &lt;\/div&gt; ))} &lt;\/div&gt; ); }; Radio Groups For the radio groups you will need custom Radio component. It's very similar to custom Checkbox one, with one difference in click handler: const Radio = ({ className = 'radio', checkedLink }) =&gt; ( &lt;div className={ className + ( checkedLink.value ? ' selected' : '' ) } onClick = { checkedLink.update( () =&gt; true ) } \/&gt; ); In this example, we bind radio to string values. It's not required for them to be strings. import { Model } from 'nestedtypes' const MyModel = Model .defaults({ option : 'option1' }); const RadioGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; { const link = model.getLink( 'option' ); return ( &lt;div&gt; &lt;div&gt; &lt;Radio checkedLink={ link.equals( 'option1' ) } \/&gt; Option 1 &lt;\/div&gt; &lt;div&gt; &lt;Radio checkedLink={ link.equals( 'option2' ) } \/&gt; Option 2 &lt;\/div&gt; &lt;\/div&gt; ); }; Input fields Standard &lt;input&gt; will work. You may implement custom input controls to handle complex scenarios with validation and appearance. const Input = ({ valueLink, className, ...props }) =&gt; ( &lt;div className='wrapping' &lt;input className={ className + ( valieLink.error ? ' error' : '' ) } {...props} value={ valueLink.value } onChange={ e =&gt; valueLink.set( e.target.value ) }\/&gt; &lt;\/div&gt; ); Errors are attached to the links automatically, when model validation is failed. Validation checks can be attached to model attributes with .has.check specification. x : Number.has.check( x =&gt; x &gt; 0 ), y : Number.has.check( x =&gt; x &lt; 0, 'y should be negative' ). Binding to model attributes import { Model } from 'nestedtypes' const MyModel = Model .defaults({ number : 0, string : '' }); const InputGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; ( &lt;div&gt; &lt;label&gt; Number: &lt;input type='number' valueLink={ model.getLink( 'number' ) } \/&gt; &lt;\/label&gt; &lt;label&gt; String: &lt;input valueLink={ model.getLink( 'string' ) } \/&gt; &lt;\/label&gt; &lt;\/div&gt; ); }; Binding to an array of strings The same technique may be used to bind to an array or hash of strings. First, take a link to this attribute. Next, use link.map method to iterate through elements links created for you. link.map will internally execute link.at( key ) method to create a link to the plain object or array element. These methods may be used manually to create binding for the structures of any particular depth and complexity. However, for the JS data with known structure it's recommended to wrap them in models. import { Model } from 'nestedtypes' const MyModel = Model .defaults({ strings : [ 'first', 'second' ] }); const InputGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; ( &lt;div&gt; { model.getLink( 'strings' ).map( strLink =&gt; ( &lt;div&gt; &lt;input type='number' valueLink={ strLink } \/&gt; &lt;\/div&gt; )) } &lt;\/div&gt; ); };","tags":"","url":"Working_With_Forms\/Advanced Data Binding.html"},{"title":"Optimizing For Performance","text":"Performance optimizations Pure Render Transactional data updates Local UI updates Old Props specs and pure render optimization One of the problems of unidirectional data flow is that large part of UI is being updated for every small change. Though React does its job avoiding unnecessary DOM manipulations, it's still takes a lot of computation resources to compare new and old UI components trees. Pure render optimization strategy avoids rendering and comparison of subtrees which has not been changed by adding special props comparison function (shouldComponentUpdate). This optimization is most effective on the top level close to the state holder component. NestedReact support this optimization, comparing props model's and collection version tokens to ones used during the last render, and comparing other props values for strict equality. To enable this optimization for the particular component, you need to: Declare all props that will be tracked for changes in props (or propTypes) spec. Which is the good practice by itself, so you encouraged to do it unless you're using stateless function components syntax, which is preferable. Add pureRender : true to component definition. As from previous example: var Bottom = React.createClass({ props : { model : Counter }, pureRender : true, render(){ const { model } = this.props; return ( &lt;div onClick={ () =&gt; model.count += 1 }&gt; { model.count } &lt;\/div&gt; ); ) }); NestedReact props spec uses the simple subset of state spec, and acts as substitution for propTypes (in fact, it internally compiles itself to the propTypes and getDefaultProps()). Following type annotations are allowed for props: Constructor functions: prop1 : String Constructors with default value: prop2 : String.value( &quot;default string&quot; ) JSON and primitive values: prop3 : &quot;default string&quot; Special PropTypes cases: PropTypes.any -&gt; undefined (no default value) or null (with null default value) PropTypes.node -&gt; React.Node PropTypes.element -&gt; React.Element If prop has explicitly declared default value, as in (2) or (3), it will be added to getDefaultProps. Partial component subtree updates For the number of reasons, you may need some parts of components subtrees to listen for props updates independently. It might be required if model or collection props are not the part of any upper component state. This situation frequently happens during transition period when you're in the middle of refactoring large backbone application. To make &lt;Bottom \/&gt; component listen to and update on its model prop change, it's enough to add listenToProps option to component spec. It will play well with pureRender, effectively avoiding unnecessary renders if top level component will trigger update on the same change too. var Bottom = React.createClass({ props : { model : Counter }, listenToProps : 'model', \/\/ space separated list of prop names \/\/ ...all other stays the same... });","tags":"","url":"Optimizing_For_Performance.html"},{"title":"Migration from Backbone","text":"Backbone to React Transition Guide There are many different ways you may approach the problem when dealing with existing Bakcbone UI. All of them are supported, enabling easy and gradual transition to React. Though NestedReact offers excellent convergence layer for backbone views, raw backbone models are not supported. To use it for smooth migration of existing backbone application to React, you need to replace backbone with NestedTypes first (it's mostly backward compatible with Backbone 1.2 API, so transition is not hard). Which by itself will be a big step forward, because: It's order of magnitude faster, so your application becomes more responsive and you can handle collection which are 10 times larger than you have now. No kidding. It implements nested models and collections in the right way. During fetch, nested objects are updated in place, so it's safe to pass them by reference. It can handle model references by id in attributes for you too, operating on a set of independently fetched collections. It's type-safe, providing the same contract for model attributes as in statically typed language. Thus, ttributes are guaranteed to hold values of declared types whatever you do, making it impossible to break client-server protocol. At the moment of writing, no other traditional model framework supports React's pure render optimization. :) For more information about NestedTypes, visit http:\/\/volicon.github.io\/backbone.nestedTypes\/ and https:\/\/github.com\/Volicon\/backbone.nestedTypes Interoperation with existing Backbone Views Key factor of success for technology transition project is to avoid naive 'upfront rewrite' strategy. An ability of running old and new code together is the game changer, allowing you to make transition process gradual. This strategy has a number of benefits, and probably one of the most significant is that you don't need to stop delivering new features. Use React components as Backbone View When you work on new features, it's natural to decide that you will write its UI with React. And, there're good news. Any React component may be used as Backbone subview. As easy as that: var backboneView = new MyReactComponent.View( props ); It will also enable you to start refactoring of your application from the bottom to top, dealing with small isolated parts of the code first. Use Backbone View in React component Or, you can decide to start refactoring from the top. In this case, you will likely want to reuse your existing lower-level backbone subviews. You can do it like that. var React = require( 'nestedreact' ); var MyComponent = React.createClass({ render : function(){ return ( &lt;div&gt; &lt;React.subview className=&quot;classes for root element&quot; View={ BackboneView } options={ viewOptions } \/&gt; &lt;\/div&gt; ); } }); It's easy, for example, to take react-router and use it in your application without any changes in Backbone View layer. Taking these two features together, you can take literally any view from the subview hierarchy, and replace it with React component. It will also work fine if there are multiple layers - React using Backbone using React... Backbone View refactoring Occasionally, you may decide to refactor your existing View to React component. Since Backbone generally use the same architectural concept as React (detect change and then render), it's an easy process. First of all, short vocabulary: View.extend({}) -&gt; React.createClass({}). That's an obvious part. View.template -&gt; Component.render(). Yeah. In React, render function just returns markup. View.render -&gt; Component.forceUpdate(). And if you want to update component, you should call this thingy instead. View.render -&gt; Component.componentDidUpdate(), Component.componentDidMount(). If you want to attach jQuery plugin after render, you do it here. View.initialize( options ) -&gt; View.componentWillMount() View options you receive in (4) -&gt; Component.props View.model -&gt; Component.state You approach the refactoring process in sequence: Create an empty React component. Take your View's template, and convert it to JSX in your component's render method. Your View's options become component's props. Modify render function accordingly. And then, the model of your View becomes your component's state. Modify render function accordingly. You copy all of your event handlers. Keep in mind - in React direct DOM manipulation is not allowed. Thus, you must render on every change, and props + state must completely define an appearance of your markup. Since for Backbone it's not so, you will likely be required to expand your View's state model. In Backbone, you might assign values from options to the model. Do not do this with React. Remember, options is props. Therefore, it might be required to remove some items from the View's model. Converting EJS template to JSX I will assume we're using EJS to be specific. JSX is not text, it's hidden JS tree construction expression, thus control structures must be transformed to functional form. In short, branches becomes logical expressions, loops becomes map expressions. Expression must return single node or array, in the last case you're required to add key attribute. Component must return single node at the top level. Keeping in mind these simple patterns, it's not that hard: class should be substitued with className &lt;%= expr %&gt; -&gt; { expr } &lt;%if( expr ){%&gt; &lt;div\/&gt; &lt;%}%&gt; -&gt; { expr &amp;&amp; &lt;div\/&gt; } &lt;%if( expr ){%&gt; &lt;div\/&gt; &lt;%}else{%&gt; &lt;span\/&gt; &lt;%}%&gt; -&gt; { expr ? &lt;div\/&gt; : &lt;span\/&gt; } &lt;%for( var i = 0; i &lt; arr.length; i++ ){%&gt; &lt;div\/&gt; &lt;%}%&gt; -&gt; { arr.map( ( x, i ) =&gt; &lt;div key={ i } \/&gt; )} You should consult official React documentation for more information about this. Use Existing Model as component's state If you already have one model, describing View's state (usual pattern is listening to model's change event and calling this.render()), you can just attach it to you React component. Like this. It will be created, disposed, and listened to automatically. var React = require( 'nestedreact' ); var MyComponent = React.createClass({ Model : MyStateModel, render : function(){ return ( &lt;div onClick={ this.onClick }&gt; { this.state.count } &lt;\/div&gt; ); }, onClick : function(){ this.state.count = this.state.count + 1; } }); Please, note. If Model is specified for the component, this.state and this.model variables holds backbone model. Usage of setState is not allowed. Generally, NestedTypes models are far superior to React's state in its capabilities, so trust me, there are nothing to regret. React component will update itself automatically whenever model emit change event. - You can customize UI update events supplying listenToState property. For example, listenToState : 'change:attr sync'. - You can disable UI updates on state change, supplying listenToState : false option. Passing Models and Collections as React components props In backbone, you might listen to models and collection changes which comes from the View options. You can do it manually in React keeping in mind that componentWIllMount is substitution for initialize, but it's not that simple because React component's lifecycle is more complicated. In contrast with Views, components are able to receive props updates. Thus, you need to handle it, and it might become tricky. To address this problem, there's special declarative syntax for events subscription from props. var MyComponent = React.createClass({ listenToProps : 'model', \/\/ listen to change, and render \/* listenToProps : { \/\/ or just string with property names, separated by space model : 'change' \/\/listen to event names separated by space, and render }, or listenToProps : { \/\/ ...if you want really wierd things... model : { 'change' : function(){ \/\/ ...you may do it. But here we are just listening to 'change', and render. this.forceUpdate(); } } }, *\/ render : function(){ return ( &lt;div onClick={ this.onClick }&gt; { this.props.model.count } &lt;\/div&gt; ); }, onClick : function(){ this.props.model.count = this.props.model.count + 1; } }); That's simple and safe. No props passed - no events subscription. Helper methods for event handlers When you will copy over your event handlers, most likely, they will just work. There are el, $el, and $( selector ) available for the React components, which simplifies refactoring of the existing event handlers and usage of jquery plugins. var React = require( 'nestedreact' ); var MyComponent = React.createClass({ onClick : function(){ this.$( '#somewhere' ).html( 'Hi' ); } }); If they don't do DOM manipulation, which is prohibited. Instead, event handlers should modify the state, or call some callbacks received from props. It is extremely dangerous and conceptually wrong to directly modify existing DOM subtree in React component. Read is safe, modify DOM when you know what you're doing. Lets say, integrating jQuery plugins. You must not use these methods in render. jquery plugins can be initialized in componentDidMount method or in event handlers.","tags":"","url":"Migration_from_Backbone.html"},{"title":"Using jQuery plugins","text":"","tags":"","url":"Using jQuery plugins.html"}]}