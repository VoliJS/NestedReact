{"pages":[{"title":"NestedReact","text":"NestedReact bridges the gap between React and traditional MVC frameworks, combining all the benefits of unidirectional data flow with two-way data binding and familiar OO state management. Features Unidirectional data flow Traditional OO data layer Same technique for managing application and UI local state &quot;pure render&quot; optimization Two-way data binding Value links Form validation Easy migration from BackboneJS Use Backbone Views from React Use React components as Backbone Views","tags":"","url":"index.html"},{"title":"Advanced Data Binding","text":"Data binding examples Here are the set of examples for typical nestedreact data binding use cases. Each section contains custom databound component, model definitions, and usage examples. Somewhere at the top level component(s) there must be the declaration linking model updates to UI. Either models must be (nested) members of some component's state (which will update UI even in case of deep changes), or you may link component updates to changes of models and collections passed in props. In the last case, you will need to add following line to top or middle-level component definition: listenToProps : 'myModel myCollection' It's generally advised to keep stateful components at the top level, and use listenToProps in the middle level for optimization purposes if you want local updates. Keep you bottom-level components pure, and try to do the same for the most of your middle level (listenToProps used wisely won't hurt). For further information on this topic consult the top-level guide. Link transformations Attribute's link can be further transformed using extended link API. Link transformations allowing you to use new stateless functions component definition style introduced in React 0.14 in most cases. For links with any value type: link.equals( x ) creates boolean link which is true whenever link value is equal to x. Useful for radio groups. link.update( x =&gt; !x ) creates function transforming link value (toggling boolean value in this case). Useful for onClick event handlers. For link enclosing array: arrLink.contains( x ) creates boolean link which is true whenever x is contained in an array in link value. Useful for checkboxes. Avoid long arrays, currently operations has O(N^2) complexity. Checkboxes Standard &lt;input\/&gt; will work. Custom Checkbox component might be implemented like this: const Checkbox = ({ className = 'checkbox', checkedLink }) =&gt; ( &lt;div className={ className + ( checkedLink.value ? ' selected' : '' ) } onClick = { checkedLink.update( x =&gt; !x ) } \/&gt; ); Examples will assume working with custom Checkbox. Binding to boolean model attributes import { Model } from 'nestedtypes' const MyModel = Model .defaults({ option1 : true, option2 : false }); const CheckboxGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; ( &lt;div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ model.getLink( 'option1' ) } \/&gt; Option 1 &lt;\/div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ model.getLink( 'option2' ) } \/&gt; Option 2 &lt;\/div&gt; &lt;\/div&gt; ); Binding to array of selected options import { Model } from 'nestedtypes' const MyModel = Model .defaults({ options : [ 'option1' ] }); const CheckboxGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; { const link = model.getLink( 'options' ); return ( &lt;div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ link.contains( 'option1' ) } \/&gt; Option 1 &lt;\/div&gt; &lt;div&gt; &lt;Checkbox checkedLink={ link.contains( 'option2' ) } \/&gt; Option 2 &lt;\/div&gt; &lt;\/div&gt; ); }; Binding to collection of selected models import { Model } from 'nestedtypes' const MyModel = Model .defaults({ all : Some.Collection, selected : Collection.subsetOf( 'all' ) }); const CheckboxGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; { const { all, selected } = model; return ( &lt;div&gt; { all.map( model =&gt; ( &lt;div&gt; &lt;Checkbox checkedLink={ selected.getLink( model ) } \/&gt; { model.displayName } &lt;\/div&gt; ))} &lt;\/div&gt; ); }; Radio Groups For the radio groups you will need custom Radio component. It's very similar to custom Checkbox one, with one difference in click handler: const Radio = ({ className = 'radio', checkedLink }) =&gt; ( &lt;div className={ className + ( checkedLink.value ? ' selected' : '' ) } onClick = { checkedLink.update( () =&gt; true ) } \/&gt; ); In this example, we bind radio to string values. It's not required for them to be strings. import { Model } from 'nestedtypes' const MyModel = Model .defaults({ option : 'option1' }); const RadioGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; { const link = model.getLink( 'option' ); return ( &lt;div&gt; &lt;div&gt; &lt;Radio checkedLink={ link.equals( 'option1' ) } \/&gt; Option 1 &lt;\/div&gt; &lt;div&gt; &lt;Radio checkedLink={ link.equals( 'option2' ) } \/&gt; Option 2 &lt;\/div&gt; &lt;\/div&gt; ); }; Input fields Standard &lt;input&gt; will work. You may implement custom input controls to handle complex scenarios with validation and appearance. const Input = ({ valueLink, className, ...props }) =&gt; ( &lt;div className='wrapping' &lt;input className={ className + ( valieLink.error ? ' error' : '' ) } {...props} value={ valueLink.value } onChange={ e =&gt; valueLink.set( e.target.value ) }\/&gt; &lt;\/div&gt; ); Errors are attached to the links automatically, when model validation is failed. Validation checks can be attached to model attributes with .has.check specification. x : Number.has.check( x =&gt; x &gt; 0 ), y : Number.has.check( x =&gt; x &lt; 0, 'y should be negative' ). Binding to model attributes import { Model } from 'nestedtypes' const MyModel = Model .defaults({ number : 0, string : '' }); const InputGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; ( &lt;div&gt; &lt;label&gt; Number: &lt;input type='number' valueLink={ model.getLink( 'number' ) } \/&gt; &lt;\/label&gt; &lt;label&gt; String: &lt;input valueLink={ model.getLink( 'string' ) } \/&gt; &lt;\/label&gt; &lt;\/div&gt; ); }; Binding to an array of strings The same technique may be used to bind to an array or hash of strings. First, take a link to this attribute. Next, use link.map method to iterate through elements links created for you. link.map will internally execute link.at( key ) method to create a link to the plain object or array element. These methods may be used manually to create binding for the structures of any particular depth and complexity. However, for the JS data with known structure it's recommended to wrap them in models. import { Model } from 'nestedtypes' const MyModel = Model .defaults({ strings : [ 'first', 'second' ] }); const InputGroup = ({ model \/* instanceof MyModel *\/ }) =&gt; ( &lt;div&gt; { model.getLink( 'strings' ).map( strLink =&gt; ( &lt;div&gt; &lt;input type='number' valueLink={ strLink } \/&gt; &lt;\/div&gt; )) } &lt;\/div&gt; ); };","tags":"","url":"Advanced Data Binding.html"},{"title":"Advanced Performance Topics","text":"Performance optimizations Pure Render Transactional data updates Local UI updates Old Props specs and pure render optimization One of the problems of unidirectional data flow is that large part of UI is being updated for every small change. Though React does its job avoiding unnecessary DOM manipulations, it's still takes a lot of computation resources to compare new and old UI components trees. Pure render optimization strategy avoids rendering and comparison of subtrees which has not been changed by adding special props comparison function (shouldComponentUpdate). This optimization is most effective on the top level close to the state holder component. NestedReact support this optimization, comparing props model's and collection version tokens to ones used during the last render, and comparing other props values for strict equality. To enable this optimization for the particular component, you need to: Declare all props that will be tracked for changes in props (or propTypes) spec. Which is the good practice by itself, so you encouraged to do it unless you're using stateless function components syntax, which is preferable. Add pureRender : true to component definition. As from previous example: var Bottom = React.createClass({ props : { model : Counter }, pureRender : true, render(){ const { model } = this.props; return ( &lt;div onClick={ () =&gt; model.count += 1 }&gt; { model.count } &lt;\/div&gt; ); ) }); NestedReact props spec uses the simple subset of state spec, and acts as substitution for propTypes (in fact, it internally compiles itself to the propTypes and getDefaultProps()). Following type annotations are allowed for props: Constructor functions: prop1 : String Constructors with default value: prop2 : String.value( &quot;default string&quot; ) JSON and primitive values: prop3 : &quot;default string&quot; Special PropTypes cases: PropTypes.any -&gt; undefined (no default value) or null (with null default value) PropTypes.node -&gt; React.Node PropTypes.element -&gt; React.Element If prop has explicitly declared default value, as in (2) or (3), it will be added to getDefaultProps. Partial component subtree updates For the number of reasons, you may need some parts of components subtrees to listen for props updates independently. It might be required if model or collection props are not the part of any upper component state. This situation frequently happens during transition period when you're in the middle of refactoring large backbone application. To make &lt;Bottom \/&gt; component listen to and update on its model prop change, it's enough to add listenToProps option to component spec. It will play well with pureRender, effectively avoiding unnecessary renders if top level component will trigger update on the same change too. var Bottom = React.createClass({ props : { model : Counter }, listenToProps : 'model', \/\/ space separated list of prop names \/\/ ...all other stays the same... });","tags":"","url":"Advanced Performance Topics.html"},{"title":"Advanced State Management","text":"Handling the complex state Nested Models and Collections State is NestedTypes model. Models 101. Passing down nested models and collections as props Nested JSON For link enclosings arrays and plain JS objects: arrOrObjLink.at( key ) creates link to array of object member with a given key. Can be applied multiple times to work with object hierarchies; on modifications, objects will be updated in purely functional way (modified parts will be shallow copied). Useful when working with plain JS objects in model attributes - updating them through links make changes visible to the model. arrOrObjLink.map( ( itemLink, key ) =&gt; &lt;input key={ key } valieLink={ itemLink } \/&gt; ) iterates through object or array, wrapping its elements to links. Useful for JSX transofrmation. Links is NestedLink library Passing down links to objects Old Passing models and collections as components props It's quite common practice to describe complex application's page state in top-level component, and pass the parts of the state down as props. In this case, any changes to nested models and collections will be detected by top-level component and will cause update of the whole subtree. Resulting in so-called unidirectional data flow. \/\/ data layer const Counter = Model.extend({ attributes : { count : 0 } }); \/\/ Application or application's page const Top = React.createClass({ \/\/ all changes made to the parts of the state will cause component update state : { model1 : Counter, model2 : Counter }, render(){ \/\/ pass down elements of the state... return ( &lt;div&gt; &lt;Bottom model={ this.state.model1 } \/&gt; &lt;Bottom model={ this.state.model2 } \/&gt; &lt;\/div&gt; ); } }); \/\/ Pure component. Click will trigger update of the Top component. const Bottom = ({ model }) =&gt; ( &lt;div onClick={ () =&gt; model.count += 1 }&gt; { model.count } &lt;\/div&gt; ); Also, this example demonstrates the point which really differentiate our approach to application state management. Here the simple fact comes into play - NestedTypes models can declaratively describe very complex state, and detect deeply nested changes. So, you have unidirectional data flow for no effort. Links and components state Link received through component props can be mapped as state member using the following declaration: state : { selected : Nested.link( '^props.selectedLink' ) } It can be accessed as a part of state, however, in this case it's not true state. All read\/write operations will be done with link itself, and local state won't be modified. Also, links can be used to declaratively expose real component state to upper conponents. In this example, link optionally received in props will be updated every time this.state.selected object is replaced. In this case, updates are one way, from bottom component to upper one, and stateful component will render itself when state is changed. state : { selected : Item.has.watcher( '^props.selectedLink.set' ) } Technically, &quot;watcher&quot; - is just a callback function with a single argument receiving new attribute value, so links are not required here.","tags":"","url":"Advanced State Management.html"},{"title":"Form Validation 101","text":"Forms validation Ad-hoc validation in render Validation in models Link validation Links carry additional validationError field for validation purposes (to be used inside of custom UI controls). It's populated automatically for links created from models and collection, utilizing nestedtypes validation mechanics. Therefore, if model attribute has any check attached, its link will carry its validationError object. var M = Nested.Model.extend({ defaults : { attr : Number.has.check( x =&gt; x &gt; 0, 'attr should be positive' ) } }); ... var m = new M({ attr : -1 }); var attrLink = m.getLink( 'attr' ); console.assert( m.value === -1 ); console.assert( m.validationError === 'attr should be positive' ); It's possible to use ad-hoc validation in component's render method with link.check method. var link = model.getLink( 'something' ) .check( x =&gt; x &gt; 0, 'Shoulld be positive' ) .check( x =&gt; x &lt; 10, 'Shoulld be lesser than 10' ); Failed checks will populate link's validationError with first failed check's message.","tags":"","url":"Form Validation 101.html"},{"title":"Integration with Backbone","text":"Backbone to React Transition Guide There are many different ways you may approach the problem when dealing with existing Bakcbone UI. All of them are supported, enabling easy and gradual transition to React. Though NestedReact offers excellent convergence layer for backbone views, raw backbone models are not supported. To use it for smooth migration of existing backbone application to React, you need to replace backbone with NestedTypes first (it's mostly backward compatible with Backbone 1.2 API, so transition is not hard). Which by itself will be a big step forward, because: It's order of magnitude faster, so your application becomes more responsive and you can handle collection which are 10 times larger than you have now. No kidding. It implements nested models and collections in the right way. During fetch, nested objects are updated in place, so it's safe to pass them by reference. It can handle model references by id in attributes for you too, operating on a set of independently fetched collections. It's type-safe, providing the same contract for model attributes as in statically typed language. Thus, ttributes are guaranteed to hold values of declared types whatever you do, making it impossible to break client-server protocol. At the moment of writing, no other traditional model framework supports React's pure render optimization. :) For more information about NestedTypes, visit http:\/\/volicon.github.io\/backbone.nestedTypes\/ and https:\/\/github.com\/Volicon\/backbone.nestedTypes Interoperation with existing Backbone Views Key factor of success for technology transition project is to avoid naive 'upfront rewrite' strategy. An ability of running old and new code together is the game changer, allowing you to make transition process gradual. This strategy has a number of benefits, and probably one of the most significant is that you don't need to stop delivering new features. Use React components as Backbone View When you work on new features, it's natural to decide that you will write its UI with React. And, there're good news. Any React component may be used as Backbone subview. As easy as that: var backboneView = new MyReactComponent.View( props ); It will also enable you to start refactoring of your application from the bottom to top, dealing with small isolated parts of the code first. Use Backbone View in React component Or, you can decide to start refactoring from the top. In this case, you will likely want to reuse your existing lower-level backbone subviews. You can do it like that. var React = require( 'nestedreact' ); var MyComponent = React.createClass({ render : function(){ return ( &lt;div&gt; &lt;React.subview className=&quot;classes for root element&quot; View={ BackboneView } options={ viewOptions } \/&gt; &lt;\/div&gt; ); } }); It's easy, for example, to take react-router and use it in your application without any changes in Backbone View layer. Taking these two features together, you can take literally any view from the subview hierarchy, and replace it with React component. It will also work fine if there are multiple layers - React using Backbone using React... Backbone View refactoring Occasionally, you may decide to refactor your existing View to React component. Since Backbone generally use the same architectural concept as React (detect change and then render), it's an easy process. First of all, short vocabulary: View.extend({}) -&gt; React.createClass({}). That's an obvious part. View.template -&gt; Component.render(). Yeah. In React, render function just returns markup. View.render -&gt; Component.forceUpdate(). And if you want to update component, you should call this thingy instead. View.render -&gt; Component.componentDidUpdate(), Component.componentDidMount(). If you want to attach jQuery plugin after render, you do it here. View.initialize( options ) -&gt; View.componentWillMount() View options you receive in (4) -&gt; Component.props View.model -&gt; Component.state You approach the refactoring process in sequence: Create an empty React component. Take your View's template, and convert it to JSX in your component's render method. Your View's options become component's props. Modify render function accordingly. And then, the model of your View becomes your component's state. Modify render function accordingly. You copy all of your event handlers. Keep in mind - in React direct DOM manipulation is not allowed. Thus, you must render on every change, and props + state must completely define an appearance of your markup. Since for Backbone it's not so, you will likely be required to expand your View's state model. In Backbone, you might assign values from options to the model. Do not do this with React. Remember, options is props. Therefore, it might be required to remove some items from the View's model. Converting EJS template to JSX I will assume we're using EJS to be specific. JSX is not text, it's hidden JS tree construction expression, thus control structures must be transformed to functional form. In short, branches becomes logical expressions, loops becomes map expressions. Expression must return single node or array, in the last case you're required to add key attribute. Component must return single node at the top level. Keeping in mind these simple patterns, it's not that hard: class should be substitued with className &lt;%= expr %&gt; -&gt; { expr } &lt;%if( expr ){%&gt; &lt;div\/&gt; &lt;%}%&gt; -&gt; { expr &amp;&amp; &lt;div\/&gt; } &lt;%if( expr ){%&gt; &lt;div\/&gt; &lt;%}else{%&gt; &lt;span\/&gt; &lt;%}%&gt; -&gt; { expr ? &lt;div\/&gt; : &lt;span\/&gt; } &lt;%for( var i = 0; i &lt; arr.length; i++ ){%&gt; &lt;div\/&gt; &lt;%}%&gt; -&gt; { arr.map( ( x, i ) =&gt; &lt;div key={ i } \/&gt; )} You should consult official React documentation for more information about this. Use Existing Model as component's state If you already have one model, describing View's state (usual pattern is listening to model's change event and calling this.render()), you can just attach it to you React component. Like this. It will be created, disposed, and listened to automatically. var React = require( 'nestedreact' ); var MyComponent = React.createClass({ Model : MyStateModel, render : function(){ return ( &lt;div onClick={ this.onClick }&gt; { this.state.count } &lt;\/div&gt; ); }, onClick : function(){ this.state.count = this.state.count + 1; } }); Please, note. If Model is specified for the component, this.state and this.model variables holds backbone model. Usage of setState is not allowed. Generally, NestedTypes models are far superior to React's state in its capabilities, so trust me, there are nothing to regret. React component will update itself automatically whenever model emit change event. - You can customize UI update events supplying listenToState property. For example, listenToState : 'change:attr sync'. - You can disable UI updates on state change, supplying listenToState : false option. Passing Models and Collections as React components props In backbone, you might listen to models and collection changes which comes from the View options. You can do it manually in React keeping in mind that componentWIllMount is substitution for initialize, but it's not that simple because React component's lifecycle is more complicated. In contrast with Views, components are able to receive props updates. Thus, you need to handle it, and it might become tricky. To address this problem, there's special declarative syntax for events subscription from props. var MyComponent = React.createClass({ listenToProps : 'model', \/\/ listen to change, and render \/* listenToProps : { \/\/ or just string with property names, separated by space model : 'change' \/\/listen to event names separated by space, and render }, or listenToProps : { \/\/ ...if you want really wierd things... model : { 'change' : function(){ \/\/ ...you may do it. But here we are just listening to 'change', and render. this.forceUpdate(); } } }, *\/ render : function(){ return ( &lt;div onClick={ this.onClick }&gt; { this.props.model.count } &lt;\/div&gt; ); }, onClick : function(){ this.props.model.count = this.props.model.count + 1; } }); That's simple and safe. No props passed - no events subscription. Helper methods for event handlers When you will copy over your event handlers, most likely, they will just work. There are el, $el, and $( selector ) available for the React components, which simplifies refactoring of the existing event handlers and usage of jquery plugins. var React = require( 'nestedreact' ); var MyComponent = React.createClass({ onClick : function(){ this.$( '#somewhere' ).html( 'Hi' ); } }); If they don't do DOM manipulation, which is prohibited. Instead, event handlers should modify the state, or call some callbacks received from props. It is extremely dangerous and conceptually wrong to directly modify existing DOM subtree in React component. Read is safe, modify DOM when you know what you're doing. Lets say, integrating jQuery plugins. You must not use these methods in render. jquery plugins can be initialized in componentDidMount method or in event handlers.","tags":"","url":"Integration with Backbone.html"},{"title":"State Management 101","text":"State management 101 NestedReact uses mutable models observing deep changes to manage UI state. Simple state management import React from 'nestedreact' export const MyComponent = React.createClass({ state : { count : 0 }, render(){ const { state } = this; return ( &lt;div onClick={ () =&gt; state.count++ }&gt; { state.count } &lt;\/div&gt; ); } }); declaration state : { [ key ] : value } assignment this.state.key = value; method this.state.transaction( body : () =&gt; void ) method this.state.set({ [ key ] : value }) method state.getLink( key ) : Link method state.linkAll( key1, key2, ... ) : { [ key ] : Link } Two-way data binding Old In the simplest case, it looks like this: import React from 'nestedreact' export const MyComponent = React.createClass({ state : { count : 0 \/\/ Number attribute with 0 as default value. }, render(){ return ( &lt;div onClick={ this.onClick }&gt; { this.state.count } &lt;\/div&gt; ); }, onClick(){ \/\/ state change will be detected and component will be updated this.state.count = this.state.count + 1; } }); Behind the scene, state is managed with NestedTypes model which is implicitly created using attribute's spec taken from state declaration (refer to NestedTypes documentation for complete attribute spec syntax). It has following implications: You can use primitive type values or constructor functions as attribute's type specs. Plain objects and arrays used as defaults will be properly deep copied. All state members must be declared in state. State attributes behaves as regular object attributes, which can be directly accessed and assigned. State attributes can hold deeply nested models and collections; deep changes will be automatically detected and will cause component update. In addition, state property from mixins will be properly merged. So, mixins can have state too. You can specify the base class for state model using Model component's property. Entire model's state can be externally defined as NestedTypes Model, and attached to component by referencing it in Model property. state supports everything what regular models can do, e.g. it can have custom methods, be transactionally changed, serialized, saved, fetched, etc. Usage of getInitialState() and setState() is not allowed when you're using state declaration. Data binding Some lower-level components like custom &lt;input \/&gt; controls does not need models and collections, rather single value. Also, there might be very different ways how particular model attribute is bound to UI control. React Link is the perfect abstraction to isolate data binding details from the UI control logic. NestedReact supports data binding links which are backward compatible with standard React's Link. You can create link for any property of the state, as well as for any model. const link = object.getLink( 'attr' ) const link = object.deepLink( 'path.to.the.attribute' ) Or, you can create boolean link, toggling model in collection. true if model is contained in collection, assignments will add\/remove given model. Useful for checkboxes. const link = collection.hasLink( model ) Links can be created directly using Link constructor, which allows you to handle any custom binding scenario: var Nested = require( 'nestedtypes' ); var link = new Nested.Link( value, x =&gt; \/* update *\/ } ); Below is the brief reference for links API. Consult Guide to Data Binding Use Cases to understand how to use it. Value access methods In addition to standard members link.requestChange( x ) and link.value, there are pair of shortcuts available: link.set( x ), which is a shortcut for this.requestChange( x ) link.toggle() is a shortcut for link.requestChange( !link.value )","tags":"","url":"State Management 101.html"},{"title":"Using jQuery plugins","text":"","tags":"","url":"Using jQuery plugins.html"}]}