<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Migration from Backbone - NestedReact</title>
    <meta name="description" content="React. Playing well with traditional MVC." />
    <meta name="author" content="Vlad Balin">
    <meta charset="UTF-8">
    <link rel="icon" href="themes/daux/img/favicon-navy.png" type="image/x-icon">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
    <!-- CSS -->
    <link href='themes/daux/css/theme-navy.min.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="with-float">
    
<header class="Navbar hidden-print">
    <a class="Navbar__brand" href="index.html">NestedReact</a>

    <div class="Search">
        <svg class="Search__icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 451 451"><path d="M447.05 428l-109.6-109.6c29.4-33.8 47.2-77.9 47.2-126.1C384.65 86.2 298.35 0 192.35 0 86.25 0 .05 86.3.05 192.3s86.3 192.3 192.3 192.3c48.2 0 92.3-17.8 126.1-47.2L428.05 447c2.6 2.6 6.1 4 9.5 4s6.9-1.3 9.5-4c5.2-5.2 5.2-13.8 0-19zM26.95 192.3c0-91.2 74.2-165.3 165.3-165.3 91.2 0 165.3 74.2 165.3 165.3s-74.1 165.4-165.3 165.4c-91.1 0-165.3-74.2-165.3-165.4z"/></svg>
        <input type="search" id="tipue_search_input" class="Search__field" placeholder="Search..." autocomplete="on" results=25 autosave=text_search>
    </div>
</header>
<div class="Columns content">
    <aside class="Columns__left Collapsible">
        <div class="Collapsible__container">
            <button type="button" class="Button Collapsible__trigger">
                <span class="Collapsible__trigger--bar"></span>
                <span class="Collapsible__trigger--bar"></span>
                <span class="Collapsible__trigger--bar"></span>
            </button>
        </div>

        <div class="Collapsible__content">
            <!-- Navigation -->
            <ul class='Nav'><li class='Nav__item '><a href="Getting_Started.html">Getting Started</a></li><li class='Nav__item  has-children'><a href="Basics/State_Management_101.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Basics</a><ul class='Nav'><li class='Nav__item '><a href="Basics/State_Management_101.html">State Management 101</a></li><li class='Nav__item '><a href="Basics/Two_way_data_binding.html">Two way data binding</a></li></ul></li><li class='Nav__item  has-children'><a href="Handling_The_Complex_State/Nested_Models_and_Collections.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Handling The Complex State</a><ul class='Nav'><li class='Nav__item '><a href="Handling_The_Complex_State/Nested_Models_and_Collections.html">Nested Models and Collections</a></li><li class='Nav__item '><a href="Handling_The_Complex_State/Aggregation_and_Ownership.html">Aggregation and Ownership</a></li><li class='Nav__item '><a href="Handling_The_Complex_State/Update_Watchers_and_Transactions.html">Update Watchers and Transactions</a></li><li class='Nav__item '><a href="Handling_The_Complex_State/Advanced State Management.html">Advanced State Management</a></li></ul></li><li class='Nav__item  has-children'><a href="Working_With_Forms/Form_Validation.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Working With Forms</a><ul class='Nav'><li class='Nav__item '><a href="Working_With_Forms/Form_Validation.html">Form Validation</a></li><li class='Nav__item '><a href="Working_With_Forms/Advanced Data Binding.html">Advanced Data Binding</a></li></ul></li><li class='Nav__item '><a href="Optimizing_For_Performance.html">Optimizing For Performance</a></li><li class='Nav__item Nav__item--active'><a href="Migration_from_Backbone.html">Migration from Backbone</a></li><li class='Nav__item '><a href="Using jQuery plugins.html">Using jQuery plugins</a></li></ul>

            <div class="Links">
                                    <hr/>
                                            <a href="https://github.com/Volicon/NestedReact/issues" target="_blank">Help/Support/Bugs</a>
                        <br />
                                            <a href="http://volicon.com" target="_blank">Made by Volicon (a Verizon company)</a>
                        <br />
                                    
                                    <div class="CodeToggler">
                        <hr/>
                                                    <span class="CodeToggler__text">Code blocks</span>
                            <div class="ButtonGroup" role="group">
                                <button class="Button Button--default Button--small CodeToggler__button CodeToggler__button--hide">No</button>
                                <button class="Button Button--default Button--small CodeToggler__button CodeToggler__button--below">Below</button>
                                <button class="Button Button--default Button--small CodeToggler__button CodeToggler__button--float">Inline</button>
                            </div>
                                            </div>
                
                                    <hr/>
                    <div class="Twitter">
                                                    <iframe allowtransparency="true" frameborder="0" scrolling="no" style="width:162px; height:20px;" src="https://platform.twitter.com/widgets/follow_button.html?screen_name=gaperton&amp;show_count=false"></iframe>
                            <br />
                            <br />
                                            </div>
                            </div>
        </div>
    </aside>
    <div class="Columns__right Columns__right--float">
        <div class="Columns__right__content">
            <div class="doc_content">
                <article class="Page">

    <div class="Page__header">
        <h1><a href="Migration_from_Backbone.html">Migration from Backbone</a></h1>
                <span style="float: left; font-size: 10px; color: gray;">
            Tuesday, August 2, 2016 9:44 AM        </span>
                        <span style="float: right; font-size: 10px; color: gray;">
            <a href="https://github.com/Volicon/NestedReact/blob/develop/docs/05_Migration_from_Backbone.md" target="_blank">Edit on GitHub</a>
        </span>
            </div>


    <div class="s-content">
        <h1 id="page_Backbone_to_React_Transition_Guide">Backbone to React Transition Guide</h1>
<p>There are many different ways you may approach the problem when dealing with existing Bakcbone UI.
All of them are supported, enabling easy and gradual transition to React.</p>
<p>Though <code>NestedReact</code> offers excellent convergence layer for backbone views, raw backbone models are not supported.
To use it for smooth migration of existing backbone application to React, you need to replace <code>backbone</code> with <code>NestedTypes</code>
first (it's mostly backward compatible with Backbone 1.2 API, so <a href="https://github.com/Volicon/NestedTypes/blob/develop/docs/BackboneTransitionGuide.md" class="external">transition is not hard</a>).
Which by itself will be a big step forward, because:</p>
<ul>
<li>
<p>It's order of magnitude faster, so your application becomes more responsive and you can handle collection which are 10 times larger than you have now. <a href="http://slides.com/vladbalin/performance#/" class="external">No kidding</a>.</p>
</li>
<li>
<p>It implements nested models and collections in the right way. During <code>fetch</code>, nested objects are updated in place, so it's safe to pass them by reference.</p>
</li>
<li>
<p>It can handle model references by <code>id</code> in attributes for you too, operating on a set of independently fetched collections.</p>
</li>
<li>
<p>It's type-safe, providing the same contract for model attributes as in statically typed language. Thus,
ttributes are guaranteed to hold values of declared types whatever you do, making it impossible to break client-server protocol.</p>
</li>
<li>
<p>At the moment of writing, no other traditional model framework supports React's pure render optimization. :)</p>
<p>For more information about <code>NestedTypes</code>, visit
	http://volicon.github.io/backbone.nestedTypes/
	and
	https://github.com/Volicon/backbone.nestedTypes</p>
</li>
</ul>
<h2 id="page_Interoperation_with_existing_Backbone_Views">Interoperation with existing Backbone Views</h2>
<p>Key factor of success for technology transition project is to avoid naive 'upfront rewrite' strategy.
An ability of running old and new code together is the game changer, allowing you to make transition process gradual.
This strategy has a number of benefits, and probably one of the most significant is that you don't need to stop
delivering new features.</p>
<h3 id="page_Use_React_components_as_Backbone_View">Use React components as Backbone View</h3>
<p>When you work on new features, it's natural to decide that you will write its UI with React.</p>
<p>And, there're good news. Any React component may be used as Backbone subview. As easy as that:</p>
<pre><code class="language-javscript">var backboneView = new MyReactComponent.View( props );
</code></pre>
<p>It will also enable you to start refactoring of your application from the bottom to top,
dealing with small isolated parts of the code first.</p>
<h3 id="page_Use_Backbone_View_in_React_component">Use Backbone View in React component</h3>
<p>Or, you can decide to start refactoring from the top. In this case, you will likely want to reuse
your existing lower-level backbone subviews.</p>
<p>You can do it like that.</p>
<pre><code class="language-javscript">var React = require( 'nestedreact' );

var MyComponent = React.createClass({
	render : function(){
		return (
			&lt;div&gt;
				&lt;React.subview
					className=&quot;classes for root element&quot;
					View={ BackboneView }
					options={ viewOptions }
				/&gt;
			&lt;/div&gt;
		);
	}
});
</code></pre>
<p>It's easy, for example, to take <a href="https://github.com/reactjs/react-router" class="external">react-router</a> and use it in your application without any changes in Backbone View layer.</p>
<p>Taking these two features together, you can take literally any view from the subview hierarchy, and replace it with
React component. It will also work fine if there are multiple layers - React using Backbone using React...</p>
<h2 id="page_Backbone_View_refactoring">Backbone View refactoring</h2>
<p>Occasionally, you may decide to refactor your existing View to React component.</p>
<p>Since Backbone generally use the same architectural concept as React (detect change and then render), it's an easy process.
First of all, short vocabulary:</p>
<ol>
<li>
<code>View.extend({})</code> -&gt; <code>React.createClass({})</code>. That's an obvious part.</li>
<li>
<code>View.template</code> -&gt; <code>Component.render()</code>. Yeah. In React, <code>render</code> function just <em>returns</em> markup.</li>
<li>
<code>View.render</code> -&gt; <code>Component.forceUpdate()</code>. And if you want to update component, you should call this thingy instead.</li>
<li>
<code>View.render</code> -&gt; <code>Component.componentDidUpdate()</code>, <code>Component.componentDidMount()</code>. If you want to attach jQuery plugin after render, you do it here.</li>
<li>
<code>View.initialize( options )</code> -&gt; <code>View.componentWillMount()</code>
</li>
<li>
<code>View options you receive in (4)</code> -&gt; <code>Component.props</code>
</li>
<li>
<code>View.model</code> -&gt; <code>Component.state</code>
</li>
</ol>
<p>You approach the refactoring process in sequence:</p>
<ol>
<li>Create an empty React component.</li>
<li>Take your View's template, and convert it to JSX in your component's render method.</li>
<li>Your View's <code>options</code> become component's <code>props</code>. Modify <code>render</code> function accordingly.</li>
<li>And then, the <code>model</code> of your View becomes your component's <code>state</code>. Modify <code>render</code> function accordingly.</li>
<li>You copy all of your event handlers.</li>
</ol>
<p>Keep in mind - in React direct DOM manipulation is not allowed. Thus, you must render on every change, and <code>props</code> + <code>state</code>
must completely define an appearance of your markup. Since for Backbone it's not so, you will likely be required to expand your
View's state model.</p>
<p>In Backbone, you might assign values from <code>options</code> to the model. Do not do this with React. Remember, <code>options</code> is <code>props</code>.
Therefore, it might be required to remove some items from the View's model.</p>
<h3 id="page_Converting_EJS_template_to_JSX">Converting EJS template to JSX</h3>
<p>I will assume we're using EJS to be specific. JSX is not text, it's hidden JS tree construction expression, thus control structures must be transformed to functional form. In short, branches becomes logical expressions, loops becomes <code>map</code> expressions. Expression must return single node or array, in the last case you're required to add <code>key</code> attribute. Component must return single node at the top level.</p>
<p>Keeping in mind these simple patterns, it's not that hard:</p>
<ul>
<li>
<code>class</code> should be substitued with <code>className</code>
</li>
<li>
<code>&lt;%= expr %&gt;</code> -&gt; <code>{ expr }</code>
</li>
<li>
<code>&lt;%if( expr ){%&gt; &lt;div/&gt; &lt;%}%&gt;</code> -&gt; <code>{ expr &amp;&amp; &lt;div/&gt; }</code>
</li>
<li>
<code>&lt;%if( expr ){%&gt; &lt;div/&gt; &lt;%}else{%&gt; &lt;span/&gt; &lt;%}%&gt;</code> -&gt; <code>{ expr ? &lt;div/&gt; : &lt;span/&gt; }</code>
</li>
<li>
<code>&lt;%for( var i = 0; i &lt; arr.length; i++ ){%&gt; &lt;div/&gt; &lt;%}%&gt;</code> -&gt; <code>{ arr.map( ( x, i ) =&gt; &lt;div key={ i } /&gt; )}</code>
</li>
</ul>
<p>You should consult official React documentation for more information about this.</p>
<h3 id="page_Use_Existing_Model_as_components_state">Use Existing Model as component's state</h3>
<p>If you already have one model, describing View's state (usual pattern is listening to model's <code>change</code> event and calling <code>this.render()</code>),
you can just attach it to you React component. Like this. It will be created, disposed, and listened to automatically.</p>
<pre><code class="language-javscript">var React = require( 'nestedreact' );

var MyComponent = React.createClass({
	Model : MyStateModel,

	render : function(){
		return (
			&lt;div onClick={ this.onClick }&gt;
				{ this.state.count }
			&lt;/div&gt;
		);
	},

	onClick : function(){
		this.state.count = this.state.count + 1;
	}
});
</code></pre>
<p><em>Please, note.</em> If Model is specified for the component,</p>
<ul>
<li>
<code>this.state</code> and <code>this.model</code> variables holds backbone model. Usage of <code>setState</code> is <em>not allowed</em>. Generally, NestedTypes
models are far superior to React's state in its capabilities, so trust me, there are nothing to regret.</li>
<li>React component will update itself automatically whenever model emit <code>change</code> event.
	- You can customize UI update events supplying <code>listenToState</code> property. For example, <code>listenToState : 'change:attr sync'</code>.
	- You can disable UI updates on state change, supplying <code>listenToState : false</code> option.</li>
</ul>
<h3 id="page_Passing_Models_and_Collections_as_React_components_props">Passing Models and Collections as React components props</h3>
<p>In backbone, you might listen to models and collection changes which comes from the View <code>options</code>.</p>
<p>You can do it manually in React keeping in mind that <code>componentWIllMount</code> is substitution for <code>initialize</code>, but it's
not that simple because React component's lifecycle is more complicated. In contrast with Views, components are able to
receive props updates. Thus, you need to handle it, and it might become tricky.</p>
<p>To address this problem, there's special declarative syntax for events subscription from <code>props</code>.</p>
<pre><code class="language-javscript">var MyComponent = React.createClass({
    listenToProps : 'model', // listen to change, and render
    /*
	listenToProps : { // or just string with property names, separated by space
		model : 'change' //listen to event names separated by space, and render 
	},
	or
	listenToProps : { // ...if you want really wierd things...
    	model : {
    	    'change' : function(){
    	        // ...you may do it. But here we are just listening to 'change', and render. 
                this.forceUpdate();     	    
    	    }
    	}
    },
    */
    
	render : function(){
		return (
			&lt;div onClick={ this.onClick }&gt;
				{ this.props.model.count }
			&lt;/div&gt;
		);
	},

	onClick : function(){
		this.props.model.count = this.props.model.count + 1;
	}
});
</code></pre>
<p>That's simple and safe. No props passed - no events subscription.</p>
<h3 id="page_Helper_methods_for_event_handlers">Helper methods for event handlers</h3>
<p>When you will copy over your event handlers, most likely, they will just work.</p>
<p>There are <code>el</code>, <code>$el</code>, and <code>$( selector )</code> available for the React components,
which simplifies refactoring of the existing event handlers and usage of
<code>jquery</code> plugins.</p>
<pre><code class="language-javscript">var React = require( 'nestedreact' );

var MyComponent = React.createClass({
	onClick : function(){
		this.$( '#somewhere' ).html( 'Hi' );
	}
});
</code></pre>
<p>If they don't do DOM manipulation, which is prohibited. Instead, event handlers should modify the state, or call some callbacks
received from props.</p>
<p>It is extremely dangerous and conceptually wrong to directly <em>modify existing</em>
DOM subtree in React component. Read is safe, modify DOM when you know what you're
doing. Lets say, integrating <code>jQuery</code> plugins.</p>
<p><em>You must not use these methods in render</em>. <code>jquery</code> plugins can be initialized
in <code>componentDidMount</code> method or in event handlers.</p>
    </div>

        <nav>
        <ul class="Pager">
            <li class=Pager--prev><a href="Optimizing_For_Performance.html">Previous</a></li>            <li class=Pager--next><a href="Using jQuery plugins.html">Next</a></li>        </ul>
    </nav>
    </article>

            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="themes/daux/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="themes/daux/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="themes/daux/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="tipuesearch/tipuesearch.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(function() {
                tipuesearch({
                    'base_url': ''
                });
            });
        </script>
    
</body>
</html>
