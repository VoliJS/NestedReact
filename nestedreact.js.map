{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9531c1e6904a1fb3797e","webpack:///./src/main.js","webpack:///external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack:///external {\"commonjs\":\"react-dom\",\"commonjs2\":\"react-dom\",\"amd\":\"react-dom\",\"root\":\"ReactDOM\"}","webpack:///external {\"commonjs\":\"nestedtypes\",\"commonjs2\":\"nestedtypes\",\"amd\":\"nestedtypes\",\"root\":\"Nested\"}","webpack:///./src/createClass.js","webpack:///./src/define.js","webpack:///./src/purerender-mixin.js","webpack:///./src/propTypes.js","webpack:///./src/component-view.js","webpack:///./src/view-element.js","webpack:///./src/nested-link.js","webpack:///./~/valuelink/valuelink.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,kBAAkB,qCAAqC,EAAE,EAAE;AACtE,YAAW,kBAAkB,qBAAqB,EAAE,EAAE;AACtD,YAAW,yBAAyB,6BAA6B,EAAE;AACnE;;AAEA,yCAAwC,sBAAsB,EAAE;AAChE;;AAEA;AACA;;AAEA;;;;;;;AC3CA,gD;;;;;;ACAA,gD;;;;;;ACAA,gD;;;;;;ACAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,+EAA8E;;AAE9E;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2EAA0E,yBAAyB;AACnG;AACA,MAAK;AACL,E;;;;;;AC1EA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,cAAc;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;;AAEA;AACA;AACA,yFAAwF;AACxF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAoC;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,iBAAgB;AAChB,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAA+E,wBAAwB;AACvG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oEAAmE;AACnE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAuG;AACvG;AACA;;AAEA,mC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC;AACrC;;AAEA,oBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA,4CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;ACzXA;AACA,8BAA6B;AAC7B,8BAA6B;;AAE7B;AACA;;AAEA;AACA;AACA;;AAEA,6DAA4D;AAC5D;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,G;;;;;;AC9BA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iC;;;;;;AC1EA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA2D;AAC3D;;AAEA;AACA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA,2DAA0D,8BAA8B;AACxF;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;;;;;;ACtFA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC,G;;;;;;ACrED;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA,sEAAqE;AACrE;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0DAAyD,wBAAwB,EAAE;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,wBAAwB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA,MAAK;;AAEL;AACA,0BAAyB,gCAAgC;AACzD;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA,MAAK;;AAEL,4CAA2C,iBAAiB;AAC5D;AACA;AACA;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA,sFAAqF;AACrF,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,mBAAmB,EAAE;AAC/C;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,8BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA8G,6BAA6B,EAAE;AAC7I;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,cAAc,EAAE;AAC7C,gCAA+B,WAAW,EAAE;AAC5C,+BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,sC","file":"./nestedreact.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"react-dom\"), require(\"nestedtypes\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"react-dom\", \"nestedtypes\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"React\"] = factory(require(\"react\"), require(\"react-dom\"), require(\"nestedtypes\"));\n\telse\n\t\troot[\"React\"] = factory(root[\"React\"], root[\"ReactDOM\"], root[\"Nested\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9531c1e6904a1fb3797e","var React    = require( 'react' ),\n    ReactDOM = require( 'react-dom' ),\n    Nested   = require( 'nestedtypes' ),\n    $        = Nested.$;\n\n// extend React namespace\nvar NestedReact = module.exports = Object.create( React );\n\n// listenToProps, listenToState, model, attributes, Model\nNestedReact.createClass = require( './createClass' );\n\nNestedReact.define = Nested.define;\nNestedReact.mixins = Nested.mixins;\n\nvar ComponentView = require( './component-view' );\n\n// export hook to override base View class used...\nNestedReact.useView = function( View ){\n    Nested._BaseView = ComponentView.use( View );\n};\n\nNestedReact.useView( Nested.View );\n\n// React component for attaching views\nNestedReact.subview = require( './view-element' );\n\nvar propTypes  = require( './propTypes' );\nNestedReact.Node = propTypes.Node.value( null );\nNestedReact.Element = propTypes.Element.value( null );\n\n// Extend react components to have backbone-style jquery accessors\nvar BackboneViewProps = {\n    el  : { get : function(){ return ReactDOM.findDOMNode( this ); } },\n    $el : { get : function(){ return $( this.el ); } },\n    $   : { value : function( sel ){ return this.$el.find( sel ); } }\n};\n\nvar Component     = React.createClass( { render : function(){} } ),\n    BaseComponent = Object.getPrototypeOf( Component.prototype );\n\nObject.defineProperties( BaseComponent, BackboneViewProps );\nObject.defineProperties( React.Component.prototype, BackboneViewProps );\n\nNestedReact.Link = require( './nested-link' );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"react-dom\",\"commonjs2\":\"react-dom\",\"amd\":\"react-dom\",\"root\":\"ReactDOM\"}\n// module id = 2\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"nestedtypes\",\"commonjs2\":\"nestedtypes\",\"amd\":\"nestedtypes\",\"root\":\"Nested\"}\n// module id = 3\n// module chunks = 0","var React       = require( 'react' ),\n    Nested      = require( 'nestedtypes' ),\n    processSpec = require( './define' ),\n    tools       = Nested.tools;\n\nvar reactMixinRules = {\n    componentWillMount        : 'reverse',\n    componentDidMount         : 'reverse',\n    componentWillReceiveProps : 'reverse',\n    shouldComponentUpdate     : 'some',\n    componentWillUpdate       : 'reverse',\n    componentDidUpdate        : 'reverse',\n    componentWillUnmount      : 'sequence',\n    state                     : 'merge',\n    store                     : 'merge',\n    props                     : 'merge',\n    context                   : 'merge',\n    childContext              : 'merge',\n    getChildContext           : 'mergeSequence'\n};\n\nfunction createClass( a_spec ){\n    var spec   = processSpec( a_spec ),\n        mixins = spec.mixins || [];\n\n    delete spec.mixins;\n\n    // We have the reversed sequence for the majority of the lifecycle hooks.\n    // So, mixins lifecycle methods works first. It's important.\n    // To make it consistent with class mixins implementation, we override React mixins.\n    for( var i = 0; i < mixins.length; i++ ){\n        Nested.mergeProps( spec, mixins[ i ], reactMixinRules );\n    }\n\n    var Component = React.createClass( spec );\n\n    // attach lazily evaluated backbone View class\n    defineBackboneProxy( Component );\n\n    return Component;\n}\n\nmodule.exports = createClass;\n\nNested.Mixable.mixTo( React.Component );\n\nReact.Component.define = function( protoProps, staticProps ){\n    var BaseClass          = tools.getBaseClass( this ),\n        staticsDefinition = tools.getChangedStatics( this, 'state', 'Model', 'props', 'autobind', 'context', 'childContext', 'listenToProps', 'pureRender' ),\n        combinedDefinition = tools.assign( staticsDefinition, protoProps || {} );\n\n    var definition = processSpec( combinedDefinition, this.prototype );\n\n    defineBackboneProxy( this );\n\n    if( definition.getDefaultProps ) this.defaultProps = definition.getDefaultProps();\n    if( definition.propTypes ) this.propTypes = definition.propTypes;\n    if( definition.contextTypes ) this.contextTypes = definition.contextTypes;\n    if( definition.childContextTypes ) this.childContextTypes = definition.childContextTypes;\n\n    var protoDefinition = tools.omit( definition, 'getDefaultProps', 'propTypes', 'contextTypes', 'childContextTypes' );\n    Nested.Mixable.define.call( this, protoDefinition, staticProps );\n\n    return this;\n}\n\nReact.Component.mixinRules( reactMixinRules );\n\nfunction defineBackboneProxy( Component ){\n    Object.defineProperty( Component, 'View', {\n        get : function(){\n            return this._View || ( this._View = Nested._BaseView.extend( { reactClass : Component } ) );\n        }\n    } );\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/createClass.js\n// module id = 4\n// module chunks = 0","var Nested = require( 'nestedtypes' ),\n    React = require( 'react' ),\n    pureRender = require( './purerender-mixin' ),\n    propTypes  = require( './propTypes' ),\n    tools = Nested.tools;\n\nmodule.exports = function processSpec( spec, a_baseProto ){\n    var baseProto = a_baseProto || {};\n    spec.mixins || ( spec.mixins = [] );\n\n    processStore( spec, baseProto );\n    processState( spec, baseProto );\n    processContext( spec, baseProto );\n    processProps( spec, baseProto );\n    processListenToProps( spec, baseProto );\n    processAutobind( spec, baseProto );\n\n    spec.mixins.push( EventsMixin );\n\n    return spec;\n};\n\n/***\n * Throttled asynchronous version of forceUpdate.\n */\nvar _queue = null;\n\nfunction asyncUpdate(){\n    // For some weird reason async update doesn't work. Input's state is being messed up.\n    // Just call forceUpdate for now.\n    this.shouldComponentUpdate === returnFalse || this._disposed || this.forceUpdate();\n}\n\nfunction returnFalse(){ return false; }\n\n/**\n * Mixin which is attached to all components.\n */\nvar EventsMixin = tools.assign( {\n    componentWillUnmount : function(){\n        // Prevent memory leaks when working with events.\n        this.off();\n        this.stopListening();\n\n        // Mark component as disposed.\n        this._disposed = true;\n    },\n\n    asyncUpdate : asyncUpdate,\n\n    /**\n     * Performs transactional update for both props and state.\n     * Suppress updates during the transaction, and force update aftewards.\n     * Wrapping the sequence of changes in a transactions guarantees that\n     * React component will be updated _after_ all the changes to the\n     * both props and local state are applied.\n     *\n     * @param fun - takes\n     */\n    transaction : function( fun ){\n        var shouldComponentUpdate = this.shouldComponentUpdate,\n              isRoot = shouldComponentUpdate !== returnFalse;\n\n        if( isRoot ){\n            this.shouldComponentUpdate = returnFalse;\n        }\n\n        fun( this.props, this.state );\n\n        if( isRoot ){\n            this.shouldComponentUpdate = shouldComponentUpdate;\n            this.asyncUpdate();\n        }\n    },\n\n    deferRender : function(){\n        var $ = Nested.$,\n            promise = $.when.apply( $, arguments ),\n            originalRender = this.render;\n\n        this.render = this.loading || defaultLoading;\n\n        var _this = this;\n        promise.always( function(){\n            _this.render = originalRender;\n            _this.asyncUpdate();\n        } );\n\n        return promise;\n    }\n}, Nested.Events );\n\nfunction defaultLoading() {\n    return React.createElement(\"div\", null);\n}\n\n/***\n * Autobinding\n */\nfunction processAutobind( spec, baseProto ){\n    if( spec.autobind ){\n        spec._autobind = spec.autobind.split( /\\s+/ ).concat( baseProto._autobind || [] );\n        spec.mixins.push( AutoBindMixin );\n        delete spec.autobind;\n    }\n}\n\nvar AutoBindMixin = {\n    componentWillMount : function(){\n        var autobind = this._autobind;\n        \n        for( var i = 0; i < autobind.length; i++ ){\n            var name = autobind[ i ];\n            this[ name ] = this[ name ].bind( this );\n        }\n    }\n};\n\nfunction processContext( spec, baseProto ){\n    // process context specs...\n    var context = getTypeSpecs( spec, 'context' );\n    if( context ){\n        spec._context = tools.defaults( context, baseProto._context || {} );\n        spec.contextTypes = propTypes.parseProps( context ).propTypes;\n        delete spec.context;\n    }\n\n    var childContext = getTypeSpecs( spec, 'childContext' );\n    if( childContext ){\n        spec._childContext = tools.defaults( childContext, baseProto._childContext || {} );\n        spec.childContextTypes = propTypes.parseProps( childContext ).propTypes;\n        delete spec.childContext;\n    }\n}\n\n// Store spec.\n\nfunction processStore( spec, baseProto ){\n    var store = getTypeSpecs( spec, 'store' );\n    if( store ){\n        delete spec.store;\n\n        if( store instanceof Nested.Store ){\n            // Direct reference to an existing store. Put it to the prototype.\n            spec.store = store;\n            spec.mixins.push( ExternalStoreMixin );\n        }\n        else {\n            spec.Store = store;\n            spec.mixins.push( InternalStoreMixin );\n            spec.mixins.push( UpdateOnNestedChangesMixin );\n        }\n\n        spec.mixins.push( ExposeStoreMixin );\n    }\n}\n\nvar UpdateOnNestedChangesMixin = {\n    _onChildrenChange : function(){},\n\n    componentDidMount : function(){\n        this._onChildrenChange = this.asyncUpdate;\n    }\n};\n\n/**\n * Attached whenever the store declaration of any form is present in the component.\n */\nvar ExposeStoreMixin = {\n    childContext : {\n        _nestedStore : Nested.Store\n    },\n\n    getChildContext : function(){\n        return { _nestedStore : this.store };\n    },\n\n    getStore : function(){\n        return this.store;\n    }\n};\n\n/**\n * External store must just track the changes and trigger render.\n * TBD: don't use it yet.\n */\nvar ExternalStoreMixin = {\n    componentDidMount : function(){\n        // Start UI updates on state changes.\n        this.listenTo( this.store, 'change', this.asyncUpdate );\n    }\n};\n\nvar InternalStoreMixin = {\n    componentWillMount : function(){\n        var store = this.store = new this.Store();\n        store._owner = this;\n        store._ownerKey = 'store';\n    },\n\n    // Will be called by the store when the lookup will fail.\n    get : function( key ){\n        // Ask upper store.\n        var store = ModelStateMixin.getStore.call( this, key );\n        return store && store.get( key );\n    },\n\n    componentWillUnmount : function(){\n        this.store._ownerKey = this.store._owner = void 0;\n        this.store.dispose();\n        this.store = null;\n    }\n};\n\n/*****************\n * State\n */\nfunction processState( spec, baseProto ){\n    // process state spec...\n    var attributes = getTypeSpecs( spec, 'state' ) || getTypeSpecs( spec, 'attributes' );\n    if( attributes || spec.Model || baseProto.Model ){\n        var BaseModel = baseProto.Model || spec.Model || Nested.Model;\n        spec.Model    = attributes ? (\n            typeof attributes === 'function' ? attributes : BaseModel.extend( { defaults : attributes } )\n        ): BaseModel;\n\n        spec.mixins.push( ModelStateMixin );\n        spec.mixins.push( UpdateOnNestedChangesMixin );\n\n        delete spec.state;\n        delete spec.attributes;\n    }\n}\n\nvar ModelStateMixin = {\n    model         : null,\n\n    componentWillMount : function(){\n        var state = this.state = this.model = this.props._keepState || new this.Model();\n        state._owner = this;\n        state._ownerKey = 'state';\n    },\n\n    context : {\n        _nestedStore : Nested.Store\n    },\n\n    // reference global store to fix model's store locator\n    getStore : function(){\n        // Attempt to get the store from the context first. Then - fallback to the state's default store.\n        // TBD: Need to figure out a good way of managing local stores.\n        var context, state;\n\n        return  ( ( context = this.context ) && context._nestedStore ) ||\n                ( ( state = this.state ) && state._defaultStore );\n    },\n\n    componentWillUnmount : function(){\n        // Release the state model.\n        this._preventDispose /* hack for component-view to preserve the state */ || this.model.dispose();\n    }\n};\n\nfunction processProps( spec, baseProto ){\n    // process props spec...\n    var props = getTypeSpecs( spec, 'props' );\n\n    if( props ){\n        spec._props = tools.defaults( props, baseProto._props || {} );\n        var parsedProps = propTypes.parseProps( props );\n\n        spec.propTypes = parsedProps.propTypes;\n\n        if( parsedProps.defaults ){\n            spec.getDefaultProps = function(){\n                return parsedProps.defaults;\n            }\n        }\n\n        delete spec.props;\n    }\n\n    // compile pure render mixin\n    if( spec.propTypes && ( spec.pureRender || baseProto.pureRender ) ){\n        spec.mixins.push( pureRender( spec.propTypes ) );\n    }\n}\n\nfunction processListenToProps( spec, baseProto ){\n    // process listenToProps spec\n    var listenToProps = spec.listenToProps;\n    if( listenToProps ){\n        if( typeof listenToProps === 'string' ){\n            spec._listenToPropsArray = listenToProps.split( /\\s+/ ).concat( baseProto._listenToPropsArray || [] );\n            spec.mixins.unshift( ListenToPropsArrayMixin );\n        }\n        else{\n            spec._listenToPropsHash = tools.defaults( listenToProps, baseProto._listenToPropsHash || {} );\n            spec.mixins.unshift( ListenToPropsMixin );\n        }\n\n        delete spec.listenToProps; \n    }\n}\n\nvar ListenToPropsMixin = {\n    componentDidMount  : regHashPropsListeners,\n    componentDidUpdate : regHashPropsListeners\n};\n\nfunction regHashPropsListeners( a_prevProps ){\n    var prevProps = a_prevProps || {},\n        updateOn  = this._listenToPropsHash;\n\n    for( var prop in updateOn ){\n        registerPropsListener( this, prevProps, prop, updateOn[ prop ] );\n    }\n}\n\nvar ListenToPropsArrayMixin = {\n    componentDidMount  : regArrayPropListeners,\n    componentDidUpdate : regArrayPropListeners\n};\n\nfunction regArrayPropListeners( a_prevProps ){\n    var prevProps = a_prevProps || {},\n        updateOn  = this._listenToPropsArray;\n\n    for( var i = 0; i < updateOn.length; i++ ){\n        registerPropsListener( this, prevProps, updateOn[ i ] )\n    }\n}\n\nfunction registerPropsListener( component, prevProps, name, events ){\n    var prevEmitter = prevProps[ name ],\n        emitter     = component.props[ name ];\n\n    if( prevEmitter !== emitter ){\n        prevEmitter && component.stopListening( prevEmitter );\n\n        if( emitter ){\n            if( typeof events === 'object' ){\n                component.listenTo( emitter, events );\n            }\n            else{\n                component.listenTo( emitter, events || emitter._changeEventName, asyncUpdate );\n            }\n        }\n    }\n}\n\nfunction getTypeSpecs( spec, name ){\n    var attributes = null;\n\n    // Scan through local mixin, and gather specs. Refactor it later, it's not good. At all.\n    for( var i = spec.mixins.length - 1; i >= 0; i-- ){\n        var mixin      = spec.mixins[ i ],\n            mixinAttrs = mixin[ name ];\n\n        if( mixinAttrs ){\n            attributes || ( attributes = {} );\n            Object.assign( attributes, mixinAttrs );\n        }\n    }\n\n    // Merge it with local data.\n    var specAttrs = spec[ name ];\n    if( specAttrs ){\n        if( attributes ){\n            Object.assign( attributes, specAttrs );\n        }\n        else{\n            attributes = specAttrs;\n        }\n    }\n\n    return attributes;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/define.js\n// module id = 5\n// module chunks = 0","module.exports = function( propTypes ){\n    var ctor      = [ 'var v;this._s=s&&s._changeToken' ],\n        isChanged = [ 'var v;return(s&&s._changeToken!==t._s)' ];\n\n    for( var name in propTypes ){\n        var propExpr = '((v=p.' + name + ')&&v._changeToken)||v';\n\n        ctor.push( 'this.' + name + '=' + propExpr );\n        isChanged.push( 't.' + name + '!==(' + propExpr + ')' );\n    }\n\n    var ChangeTokens = new Function( 'p', 's', ctor.join( ';' ) ),\n        isChanged    = new Function( 't', 'p', 's', isChanged.join( '||' ) );\n\n    ChangeTokens.prototype = null;\n\n    return {\n        _changeTokens : null,\n\n        shouldComponentUpdate : function( nextProps ){\n            return isChanged( this._changeTokens, nextProps, this.state );\n        },\n\n        componentDidMount  : function(){\n            this._changeTokens = new ChangeTokens( this.props, this.state );\n        },\n        componentDidUpdate : function(){\n            this._changeTokens = new ChangeTokens( this.props, this.state );\n        }\n    }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/purerender-mixin.js\n// module id = 6\n// module chunks = 0","/**\n * props compiler.\n * Translates `props` spec to `propTypes` and `getDefaultProps` function.\n */\n\nvar Nested = require( 'nestedtypes' ),\n    React  = require( 'react' );\n\nfunction parseProps( props ){\n    var propTypes = {},\n        defaults,\n        // Create NestedTypes model definition to process props spec.\n        modelProto = Nested.Model.defaults( props ).prototype;\n\n    modelProto.forEachAttr( modelProto._attributes, function( spec, name ){\n        // Skip auto-generated `id` attribute.\n        if( name !== 'id' ){\n            // Translate props type to the propTypes guard.\n            propTypes[ name ] = translateType( spec.type, spec.options.isRequired );\n\n            // If default value is explicitly provided...\n            if( spec.value !== void 0 ){\n                //...append it to getDefaultProps function.\n                defaults || ( defaults = {} );\n                defaults[ name ] = spec.convert( spec.value );\n            }\n        }\n    });\n\n    return {\n        propTypes : propTypes,\n        defaults : defaults\n    };\n}\n\nvar PropTypes = React.PropTypes;\n\nfunction Node(){}\nfunction Element(){}\n\nfunction translateType( Type, isRequired ){\n    var T = _translateType( Type );\n    return isRequired ? T.isRequired : T;\n}\n\nfunction _translateType( Type ){\n    switch( Type ){\n        case Number :\n        case Integer :\n            return PropTypes.number;\n        case String :\n            return PropTypes.string;\n        case Boolean :\n            return PropTypes.bool;\n        case Array :\n            return PropTypes.array;\n        case Function :\n            return PropTypes.func;\n        case Object :\n            return PropTypes.object;\n        case Node :\n            return PropTypes.node;\n        case Element :\n            return PropTypes.element;\n        case void 0 :\n        case null :\n            return PropTypes.any;\n        default:\n            return PropTypes.instanceOf( Type );\n    }\n}\n\nexports.Node = Node;\nexports.Element = Element;\nexports.parseProps = parseProps;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/propTypes.js\n// module id = 7\n// module chunks = 0","var React    = require( 'react' ),\n    ReactDOM = require( 'react-dom' );\n\nfunction fastAssign( dest, source ){\n    for( var name in source ) {\n        dest[ name ] = source[ name ];\n    }\n\n    return dest;\n}\n\nmodule.exports.use = function( View ){\n    var dispose    = View.prototype.dispose || function(){},\n        setElement = View.prototype.setElement;\n\n    var ComponentView = View.extend( {\n        reactClass : null,\n        props      : {},\n        element    : null,\n\n        initialize : function( props ){\n            // memorise arguments to pass to React\n            this.options = props || {};\n        },\n\n        setElement : function(){\n            this.unmountComponent( true );\n            return setElement.apply( this, arguments );\n        },\n\n        // cached instance of react component...\n        component : null,\n        prevState : null,\n        \n        resize : function(){\n            Page.forceResize();\n        },\n\n        render : function(){\n            var options   = this.prevState ? fastAssign( { _keepState : this.prevState }, this.options ) : this.options,\n                element   = React.createElement( this.reactClass, options ),\n                component = ReactDOM.render( element, this.el );\n\n            this.component || this.mountComponent( component );\n        },\n\n        mountComponent : function( component ){\n            this.component = component;\n            this.prevState = null;\n\n            component.trigger && this.listenTo( component, 'all', function(){\n                this.trigger.apply( this, arguments );\n            } );\n        },\n\n        unmountComponent : function( keepModel ){\n            var component = this.component;\n\n            if( component ){\n                this.prevState = component.model;\n\n                if( component.trigger ){\n                    this.stopListening( component );\n                }\n\n                component._preventDispose = Boolean( keepModel );\n\n                ReactDOM.unmountComponentAtNode( this.el );\n                this.component = null;\n            }\n        },\n\n        dispose : function(){\n            this.unmountComponent();\n            return dispose.apply( this, arguments );\n        }\n    } );\n\n    Object.defineProperty( ComponentView.prototype, 'model', {\n        get : function(){\n            this.component || this.render();\n            return this.component && this.component.model;\n        }\n    } );\n\n    return ComponentView;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/component-view.js\n// module id = 8\n// module chunks = 0","var React        = require( 'react' ),\n    jsonNotEqual = require( 'nestedtypes' ).tools.notEqual;\n\nmodule.exports = React.createClass( {\n    displayName : 'BackboneView',\n\n    propTypes : {\n        View    : React.PropTypes.func.isRequired,\n        options : React.PropTypes.object\n    },\n\n    shouldComponentUpdate : function( next ){\n        var props = this.props;\n        return next.View !== props.View || jsonNotEqual( next.options, props.options );\n    },\n\n    hasUnsavedChanges : function(){\n        var view = this.view;\n\n        return view && (\n                typeof view.hasUnsavedChanges === 'function' ? view.hasUnsavedChanges() : view.hasUnsavedChanges\n            );\n    },\n\n    render : function(){\n        return React.DOM.div( {\n            ref       : 'subview',\n            className : this.props.className\n        } );\n    },\n\n    componentDidMount    : function(){\n        this._mountView();\n    },\n\n    componentDidUpdate   : function(){\n        this._dispose();\n        this._mountView();\n    },\n\n    componentWillUnmount : function(){\n        this._dispose();\n    },\n\n    _mountView : function(){\n        var el = this.refs.subview,\n            p  = this.props;\n\n        var view = this.view = p.options ? new p.View( p.options ) : new p.View();\n\n        el.appendChild( view.el );\n        view.render();\n    },\n\n    _dispose : function(){\n        var view = this.view;\n        if( view ){\n            if( view.dispose ){\n                view.dispose();\n            }\n            else{\n                view.stopListening();\n                view.off();\n            }\n\n            this.refs.subview.innerHTML = \"\";\n            this.view                   = null;\n        }\n    }\n} );\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/view-element.js\n// module id = 9\n// module chunks = 0","var Nested = require( 'nestedtypes' ),\n    Link   = require( 'valuelink' ).default;\n\nmodule.exports = Nested.Link = Link;\n\nNested.Mixable.mixTo( Link );\n\n/**\n * Link to NestedType's model attribute.\n * Strict evaluation of value, lazy evaluation of validation error.\n * Links are cached in the models\n */\nfunction ModelLink( model, attr, value ){\n    Link.call( this, value );\n    this.model = model;\n    this.attr  = attr;\n}\n\nModelLink.prototype = Object.create( Link.prototype, {\n    constructor : { value : ModelLink },\n    set         : {\n        value : function( x ){\n            this.model[ this.attr ] = x;\n        }\n    },\n\n    error : {\n        get : function(){\n            return this._error === void 0 ? this.model.getValidationError( this.attr ): this._error;\n        },\n\n        set : function( x ){\n            this._error = x;\n        }\n    }\n} );\n\nvar ModelProto = Nested.Record.prototype;\n\nObject.defineProperty( ModelProto, 'links', {\n    get : function(){\n        return this._links || ( this._links = new this.Attributes( {} ) );\n    }\n});\n\nfunction cacheLink( links, model, key ){\n    var cached = links[ key ],\n        value = model[ key ];\n\n    return cached && cached.value === value ? cached\n                : links[ key ] = new ModelLink( model, key, value );\n}\n\nModelProto.getLink = function( key ){\n    return cacheLink( this.links, this, key );\n};\n\nModelProto.linkAll = function(){\n    var links = this.links;\n\n    if( arguments.length ){\n        for( var i = 0; i < arguments.length; i++ ){\n            cacheLink( links, this, arguments[ i ] );\n        }\n    }\n    else{\n        var attributes = this.attributes;\n\n        for( var key in attributes ){\n            attributes[ key ] === void 0 || cacheLink( links, this, key );\n        }\n    }\n\n    return links;\n};\n\n/**\n * Boolean link to presence of NestedType's model in collection.\n * Strict evaluation of value, no error.\n * Safe implementation of _changeToken.\n * @param collection\n * @param model\n * @constructor\n */\nfunction CollectionLink( collection, model ){\n    Link.call( this, Boolean( collection._byId[ model.cid ] ) );\n    this.collection = collection;\n    this.model      = model;\n}\n\nCollectionLink.prototype = Object.create( Link.prototype, {\n    constructor : { value : CollectionLink },\n    set : {\n        value : function( x ){\n            this.collection.toggle( this.model, x );\n        }\n    }\n} );\n\nvar CollectionProto = Nested.Record.Collection.prototype;\n\nCollectionProto.hasLink = function( model ){\n    return new CollectionLink( this, model );\n};\n\nCollectionProto.getLink = function( prop ){\n    var collection = this;\n    return Link.value( collection[ prop ], function( x ){ collection[ prop ] = x; });\n};\n\nfunction ModelDeepLink( model, path, options ){\n    Link.call( this, model.deepGet( path ) );\n    this.model   = model;\n    this.path    = path;\n    this.options = options;\n}\n\nModelDeepLink.prototype = Object.create( Link.prototype, {\n    constructor : { value : ModelDeepLink },\n\n    error : {\n        get : function(){\n            if( this._error === void 0 ){\n                this._error = this.model.deepValidationError( this.path ) || null;\n            }\n\n            return this._error;\n        },\n\n        set : function( x ){\n            this._error = x;\n        }\n    },\n\n    _changeToken : {\n        get : function(){ return this.model._changeToken; }\n    }\n} );\n\nModelDeepLink.prototype.set = function( x ){\n    this.model.deepSet( this.path, x, this.options );\n};\n\nModelProto.deepLink = function( path, options ){\n    return new ModelDeepLink( this, path, options )\n};\n\nNested.link = function( reference ){\n    var getMaster = Nested.parseReference( reference );\n\n    function setLink( value ){\n        var link = getMaster.call( this );\n        link && link.set( value );\n    }\n\n    function getLink(){\n        var link = getMaster.call( this );\n        return link && link.value;\n    }\n\n    var LinkAttribute = Nested.attribute.Type.extend( {\n        createPropertySpec : function(){\n            return {\n                // call to optimized set function for single argument. Doesn't work for backbone types.\n                set : setLink,\n\n                // attach get hook to the getter function, if present\n                get : getLink\n            }\n        },\n\n        set : setLink\n    } );\n\n    var options       = Nested.attribute( { toJSON : false } );\n    options.Attribute = LinkAttribute;\n    return options;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/nested-link.js\n// module id = 10\n// module chunks = 0","/**\r\n * Advanced React links for purely functional two-way data binding\r\n *\r\n * MIT License, (c) 2016 Vlad Balin, Volicon.\r\n */\r\n\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n// Main Link class. All links must extend it.\r\nvar Link = (function () {\r\n    // create \r\n    function Link(value) {\r\n        this.value = value;\r\n    }\r\n    // Create link to componen't state\r\n    Link.state = function (component, key) {\r\n        var value = component.state[key], cache = component.links || (component.links = {}), cached = cache[key];\r\n        return cached && cached.value === value ? cached : cache[key] = new StateLink(value, component, key);\r\n    };\r\n    ;\r\n    // Ensure that listed links are cached. Return links cache.\r\n    Link.all = function (component) {\r\n        var state = component.state, links = component.links || (component.links = {});\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            var key = arguments[i], value = state[key], cached = links[key];\r\n            if (!cached || cached.value !== value) {\r\n                links[key] = new StateLink(value, component, key);\r\n            }\r\n        }\r\n        return links;\r\n    };\r\n    // Create custom link to arbitrary value\r\n    Link.value = function (value, set) {\r\n        return new CustomLink(value, set);\r\n    };\r\n    Object.defineProperty(Link.prototype, \"validationError\", {\r\n        // DEPRECATED: Old error holder for backward compatibility with Volicon code base\r\n        get: function () { return this.error; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Link.prototype.onChange = function (handler) {\r\n        var _this = this;\r\n        return new CloneLink(this, function (x) {\r\n            handler(x);\r\n            _this.set(x);\r\n        });\r\n    };\r\n    // DEPRECATED: Old React method for backward compatibility\r\n    Link.prototype.requestChange = function (x) {\r\n        this.set(x);\r\n    };\r\n    // Immediately update the link value using given transform function.\r\n    Link.prototype.update = function (transform, e) {\r\n        var next = transform(this.clone(), e);\r\n        next === void 0 || this.set(next);\r\n    };\r\n    // Create new link which applies transform function on set.\r\n    Link.prototype.pipe = function (handler) {\r\n        var _this = this;\r\n        return new CloneLink(this, function (x) {\r\n            var next = handler(x, _this.value);\r\n            next === void 0 || _this.set(next);\r\n        });\r\n    };\r\n    // Create UI event handler function which will update the link with a given transform function.\r\n    Link.prototype.action = function (transform) {\r\n        var _this = this;\r\n        return function (e) { return _this.update(transform, e); };\r\n    };\r\n    Link.prototype.equals = function (truthyValue) {\r\n        return new EqualsLink(this, truthyValue);\r\n    };\r\n    Link.prototype.enabled = function (defaultValue) {\r\n        if (defaultValue === void 0) { defaultValue = ''; }\r\n        return new EnabledLink(this, defaultValue);\r\n    };\r\n    // Array-only links methods\r\n    Link.prototype.contains = function (element) {\r\n        return new ContainsLink(this, element);\r\n    };\r\n    Link.prototype.push = function () {\r\n        var array = arrayHelpers.clone(this.value);\r\n        Array.prototype.push.apply(array, arguments);\r\n        this.set(array);\r\n    };\r\n    Link.prototype.unshift = function () {\r\n        var array = arrayHelpers.clone(this.value);\r\n        Array.prototype.unshift.apply(array, arguments);\r\n        this.set(array);\r\n    };\r\n    Link.prototype.splice = function () {\r\n        var array = arrayHelpers.clone(this.value);\r\n        Array.prototype.splice.apply(array, arguments);\r\n        this.set(array);\r\n    };\r\n    // Array and objects universal collection methods\r\n    Link.prototype.map = function (iterator) {\r\n        return helpers(this.value).map(this, iterator);\r\n    };\r\n    Link.prototype.remove = function (key) {\r\n        var value = this.value, _ = helpers(value);\r\n        this.set(_.remove(_.clone(value), key));\r\n    };\r\n    Link.prototype.at = function (key) {\r\n        return new ChainedLink(this, key);\r\n    };\r\n    Link.prototype.clone = function () {\r\n        var value = this.value;\r\n        return helpers(value).clone(value);\r\n    };\r\n    Link.prototype.pick = function () {\r\n        var links = {};\r\n        for (var i = 0; i < arguments.length; i++) {\r\n            var key = arguments[i];\r\n            links[key] = new ChainedLink(this, key);\r\n        }\r\n        return links;\r\n    };\r\n    /**\r\n     * Validate link with validness predicate and optional custom error object. Can be chained.\r\n     */\r\n    Link.prototype.check = function (whenValid, error) {\r\n        if (!this.error && !whenValid(this.value)) {\r\n            this.error = error || whenValid.error || defaultError;\r\n        }\r\n        return this;\r\n    };\r\n    return Link;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Link;\r\nvar CustomLink = (function (_super) {\r\n    __extends(CustomLink, _super);\r\n    function CustomLink(value, set) {\r\n        _super.call(this, value);\r\n        this.set = set;\r\n    }\r\n    CustomLink.prototype.set = function (x) { };\r\n    return CustomLink;\r\n}(Link));\r\nexports.CustomLink = CustomLink;\r\nvar CloneLink = (function (_super) {\r\n    __extends(CloneLink, _super);\r\n    function CloneLink(parent, set) {\r\n        _super.call(this, parent.value);\r\n        this.set = set;\r\n        var error = parent.error;\r\n        if (error)\r\n            this.error = error;\r\n    }\r\n    CloneLink.prototype.set = function (x) { };\r\n    return CloneLink;\r\n}(Link));\r\nexports.CloneLink = CloneLink;\r\nvar StateLink = (function (_super) {\r\n    __extends(StateLink, _super);\r\n    function StateLink(value, component, key) {\r\n        _super.call(this, value);\r\n        this.component = component;\r\n        this.key = key;\r\n    }\r\n    StateLink.prototype.set = function (x) {\r\n        this.component.setState((_a = {}, _a[this.key] = x, _a));\r\n        var _a;\r\n    };\r\n    return StateLink;\r\n}(Link));\r\nexports.StateLink = StateLink;\r\nvar EqualsLink = (function (_super) {\r\n    __extends(EqualsLink, _super);\r\n    function EqualsLink(parent, truthyValue) {\r\n        _super.call(this, parent.value === truthyValue);\r\n        this.parent = parent;\r\n        this.truthyValue = truthyValue;\r\n    }\r\n    EqualsLink.prototype.set = function (x) {\r\n        this.parent.set(x ? this.truthyValue : null);\r\n    };\r\n    return EqualsLink;\r\n}(Link));\r\nexports.EqualsLink = EqualsLink;\r\nvar EnabledLink = (function (_super) {\r\n    __extends(EnabledLink, _super);\r\n    function EnabledLink(parent, defaultValue) {\r\n        _super.call(this, parent.value != null);\r\n        this.parent = parent;\r\n        this.defaultValue = defaultValue;\r\n    }\r\n    EnabledLink.prototype.set = function (x) {\r\n        this.parent.set(x ? this.defaultValue : null);\r\n    };\r\n    return EnabledLink;\r\n}(Link));\r\nexports.EnabledLink = EnabledLink;\r\nvar ContainsLink = (function (_super) {\r\n    __extends(ContainsLink, _super);\r\n    function ContainsLink(parent, element) {\r\n        _super.call(this, parent.value.indexOf(element) >= 0);\r\n        this.parent = parent;\r\n        this.element = element;\r\n    }\r\n    ContainsLink.prototype.set = function (x) {\r\n        var _this = this;\r\n        var next = Boolean(x);\r\n        if (this.value !== next) {\r\n            var arr = this.parent.value, nextValue = x ? arr.concat(this.element) : arr.filter(function (el) { return el !== _this.element; });\r\n            this.parent.set(nextValue);\r\n        }\r\n    };\r\n    return ContainsLink;\r\n}(Link));\r\nexports.ContainsLink = ContainsLink;\r\nvar defaultError = 'Invalid value';\r\n/**\r\n * Link to array or object element enclosed in parent link.\r\n * Performs purely functional update of the parent, shallow copying its value on `set`.\r\n */\r\nvar ChainedLink = (function (_super) {\r\n    __extends(ChainedLink, _super);\r\n    function ChainedLink(parent, key) {\r\n        _super.call(this, parent.value[key]);\r\n        this.parent = parent;\r\n        this.key = key;\r\n    }\r\n    ChainedLink.prototype.remove = function (key) {\r\n        if (key === void 0) {\r\n            this.parent.remove(this.key);\r\n        }\r\n        else {\r\n            _super.prototype.remove.call(this, key);\r\n        }\r\n    };\r\n    // Set new element value to parent array or object, performing purely functional update.\r\n    ChainedLink.prototype.set = function (x) {\r\n        var _this = this;\r\n        if (this.value !== x) {\r\n            this.parent.update(function (value) {\r\n                value[_this.key] = x;\r\n                return value;\r\n            });\r\n        }\r\n    };\r\n    ;\r\n    return ChainedLink;\r\n}(Link));\r\nexports.ChainedLink = ChainedLink;\r\nvar ArrayProto = Array.prototype, ObjectProto = Object.prototype;\r\nfunction helpers(value) {\r\n    if (value && typeof value === 'object') {\r\n        switch (Object.getPrototypeOf(value)) {\r\n            case ArrayProto: return arrayHelpers;\r\n            case ObjectProto: return objectHelpers;\r\n        }\r\n    }\r\n    return dummyHelpers;\r\n}\r\n// Do nothing for types other than Array and plain Object.\r\nvar dummyHelpers = {\r\n    clone: function (value) { return value; },\r\n    map: function (link, fun) { return []; },\r\n    remove: function (value) { return value; }\r\n};\r\n// `map` and `clone` for plain JS objects\r\nvar objectHelpers = {\r\n    // Map through the link to object\r\n    map: function (link, iterator) {\r\n        var hash = link.value;\r\n        var mapped = [];\r\n        for (var key in hash) {\r\n            var element = iterator(link.at(key), key);\r\n            element === void 0 || (mapped.push(element));\r\n        }\r\n        return mapped;\r\n    },\r\n    remove: function (object, key) {\r\n        delete object[key];\r\n        return object;\r\n    },\r\n    // Shallow clone plain JS object\r\n    clone: function (object) {\r\n        var cloned = {};\r\n        for (var key in object) {\r\n            cloned[key] = object[key];\r\n        }\r\n        return cloned;\r\n    }\r\n};\r\n// `map` and `clone` helpers for arrays.\r\nvar arrayHelpers = {\r\n    // Shallow clone array\r\n    clone: function (array) {\r\n        return array.slice();\r\n    },\r\n    remove: function (array, i) {\r\n        array.splice(i, 1);\r\n        return array;\r\n    },\r\n    // Map through the link to array\r\n    map: function (link, iterator) {\r\n        var mapped = [], array = link.value;\r\n        for (var i = 0; i < array.length; i++) {\r\n            var y = iterator(link.at(i), i);\r\n            y === void 0 || (mapped.push(y));\r\n        }\r\n        return mapped;\r\n    }\r\n};\r\n//# sourceMappingURL=valuelink.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/valuelink/valuelink.js\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}